Your task is to generate a Cypher query based on a research question to retrieve conflict-related data from RULAC, including relevant countries, state actors, non-state actors, geographical regions, and conflict classifications.

# Important Requirements for Cypher Queries

Primary Goal: Ensure the query retrieves relevant conflict data.

Return Structure:
The cypher query should always return a structured object named RULAC_research.
Inside this object, include:

1. summary
A human-readable summary of the findings, formatted as a sentence or paragraph.
If no conflicts are found, the summary should state that explicitly.
If conflicts are found, the summary should describe the number of conflicts, their types, and any key insights.

2. conflict_details:
A list of distinct conflicts, including conflict name, classification, overview, applicable IHL law, state and non-state actors, and citation.

Strict Schema Adherence:
Use only the provided schema's node labels, relationships, and properties.
Do not invent new properties or relationships.

# Instructions:
1. Identify any actors, regions, or conflict types mentioned in the question.
2. Use **only** the relationship types and properties provided in the schema. Do not use anything else that is not in the schema.
3. Ensure the query retrieves all conflicts, state actors, non-state actors, classifications, and other properties as shown in the examples.
4. Avoid directly matching conflicts by state actor name or country name. Instead, match conflicts using the UN M49 code of the relevant country or state actor.
4b. Never match a NonStateActor directly by name property alone, but rather by name and alias, and always including lowercase comparisons for flexible retrieval.
5. If the research question pertains to a country or state actor's involvement in conflict, match the state actor UN_M49 code to the conflict. If pertaining to a conflict taking place or physically present in the country, match a conflict to UN_M49 code in the Country in which the conflict IS_TAKING_PLACE_IN_COUNTRY.
6. Ignore dates in the query, as all conflicts in RULAC are considered actively present, ongoing, and generally relevant to the question.
7. Use the `conflict_details` array to store the details of each conflict.

Hierarchical UN M49 Regional Grouping:
World (001)
  ├── Africa (002)
  │   ├── Northern Africa (015)
  │   ├── Sub-Saharan Africa (202)
  │   │   ├── Eastern Africa (014)
  │   │   ├── Middle Africa (017)
  │   │   ├── Southern Africa (018)
  │   │   └── Western Africa (011)
  ├── Americas (019)
  │   ├── North America (003)
  │   │   ├── Northern America (021)
  │   │   ├── Caribbean (029)
  │   │   └── Central America (013)
  │   └── Latin America and the Caribbean (419)
  │       ├── Caribbean (029)
  │       ├── Central America (013)
  │       └── South America (005)
  ├── Antarctica (010)
  ├── Asia (142)
  │   ├── Central Asia (143)
  │   ├── Eastern Asia (030)
  │   ├── South-Eastern Asia (035)
  │   ├── Southern Asia (034)
  │   └── Western Asia (145)
  ├── Europe (150)
  │   ├── Eastern Europe (151)
  │   ├── Northern Europe (154)
  │   ├── Southern Europe (039)
  │   └── Western Europe (155)
  └── Oceania (009)
      └── Small Island Developing States (SIDS) (722)

Special UN M49 Codes:
- 729 for modern Sudan after the separation of South Sudan in 2011
- 275 for Palestine

Use the hierarchical UN M49 regional groupings to determine whether to match conflicts to a specific region or if it should be summed up for a broader region. Avoid matching conflicts to both a parent region and its subregion at the same time.

## Full list of countries and their UN M49 Codes

- Afghanistan ("004")
- Albania ("008")
- Antarctica ("010")
- Algeria ("012")
- American Samoa ("016")
- Andorra ("020")
- Angola ("024")
- Antigua and Barbuda ("028")
- Azerbaijan ("031")
- Argentina ("032")
- Australia ("036")
- Austria ("040")
- Bahamas ("044")
- Bahrain ("048")
- Bangladesh ("050")
- Armenia ("051")
- Barbados ("052")
- Belgium ("056")
- Bermuda ("060")
- Bhutan ("064")
- Bolivia (Plurinational State of) ("068")
- Bosnia and Herzegovina ("070")
- Botswana ("072")
- Bouvet Island ("074")
- Brazil ("076")
- Belize ("084")
- British Indian Ocean Territory ("086")
- Solomon Islands ("090")
- British Virgin Islands ("092")
- Brunei Darussalam ("096")
- Bulgaria ("100")
- Myanmar ("104")
- Burundi ("108")
- Belarus ("112")
- Cambodia ("116")
- Cameroon ("120")
- Canada ("124")
- Cabo Verde ("132")
- Cayman Islands ("136")
- Central African Republic ("140")
- Sri Lanka ("144")
- Chad ("148")
- Chile ("152")
- China ("156")
- Christmas Island ("162")
- Cocos (Keeling) Islands ("166")
- Colombia ("170")
- Comoros ("174")
- Mayotte ("175")
- Congo ("178")
- Democratic Republic of the Congo ("180")
- Cook Islands ("184")
- Costa Rica ("188")
- Croatia ("191")
- Cuba ("192")
- Cyprus ("196")
- Czechia ("203")
- Benin ("204")
- Denmark ("208")
- Dominica ("212")
- Dominican Republic ("214")
- Ecuador ("218")
- El Salvador ("222")
- Equatorial Guinea ("226")
- Ethiopia ("231")
- Eritrea ("232")
- Estonia ("233")
- Faroe Islands ("234")
- Falkland Islands (Malvinas) ("238")
- South Georgia and the South Sandwich Islands ("239")
- Fiji ("242")
- Finland ("246")
- Åland Islands ("248")
- France ("250")
- French Guiana ("254")
- French Polynesia ("258")
- French Southern Territories ("260")
- Djibouti ("262")
- Gabon ("266")
- Georgia ("268")
- Gambia ("270")
- Palestine ("275")
- Germany ("276")
- Ghana ("288")
- Gibraltar ("292")
- Kiribati ("296")
- Greece ("300")
- Greenland ("304")
- Grenada ("308")
- Guadeloupe ("312")
- Guam ("316")
- Guatemala ("320")
- Guinea ("324")
- Guyana ("328")
- Haiti ("332")
- Heard Island and McDonald Islands ("334")
- Holy See ("336")
- Honduras ("340")
- Hungary ("348")
- Iceland ("352")
- India ("356")
- Indonesia ("360")
- Iran ("364")
- Iraq ("368")
- Ireland ("372")
- Israel ("376")
- Italy ("380")
- Côte d’Ivoire ("384")
- Jamaica ("388")
- Japan ("392")
- Kazakhstan ("398")
- Jordan ("400")
- Kenya ("404")
- Democratic People's Republic of Korea ("408")
- Republic of Korea ("410")
- Kuwait ("414")
- Kyrgyzstan ("417")
- Lao People's Democratic Republic ("418")
- Lebanon ("422")
- Lesotho ("426")
- Latvia ("428")
- Liberia ("430")
- Libya ("434")
- Liechtenstein ("438")
- Lithuania ("440")
- Luxembourg ("442")
- Madagascar ("450")
- Malawi ("454")
- Malaysia ("458")
- Maldives ("462")
- Mali ("466")
- Malta ("470")
- Martinique ("474")
- Mauritania ("478")
- Mauritius ("480")
- Mexico ("484")
- Monaco ("492")
- Mongolia ("496")
- Republic of Moldova ("498")
- Montenegro ("499")
- Montserrat ("500")
- Morocco ("504")
- Mozambique ("508")
- Oman ("512")
- Namibia ("516")
- Nauru ("520")
- Nepal ("524")
- Netherlands ("528")
- Curaçao ("531")
- Aruba ("533")
- Sint Maarten (Dutch part) ("534")
- New Caledonia ("540")
- Vanuatu ("548")
- New Zealand ("554")
- Nicaragua ("558")
- Niger ("562")
- Nigeria ("566")
- Niue ("570")
- Norfolk Island ("574")
- Norway ("578")
- Northern Mariana Islands ("580")
- United States Minor Outlying Islands ("581")
- Micronesia (Federated States of) ("583")
- Marshall Islands ("584")
- Palau ("585")
- Pakistan ("586")
- Panama ("591")
- Papua New Guinea ("598")
- Paraguay ("600")
- Peru ("604")
- Philippines ("608")
- Pitcairn ("612")
- Poland ("616")
- Portugal ("620")
- Guinea-Bissau ("624")
- Timor-Leste ("626")
- Puerto Rico ("630")
- Qatar ("634")
- Réunion ("638")
- Romania ("642")
- Russian Federation ("643")
- Rwanda ("646")
- Saint Barthélemy ("652")
- Saint Helena ("654")
- Saint Kitts and Nevis ("659")
- Anguilla ("660")
- Saint Lucia ("662")
- Saint Martin (French Part) ("663")
- Saint Pierre and Miquelon ("666")
- Saint Vincent and the Grenadines ("670")
- San Marino ("674")
- Sao Tome and Principe ("678")
- Saudi Arabia ("682")
- Senegal ("686")
- Serbia ("688")
- Seychelles ("690")
- Sierra Leone ("694")
- Singapore ("702")
- Slovakia ("703")
- Viet Nam ("704")
- Slovenia ("705")
- Somalia ("706")
- South Africa ("710")
- Zimbabwe ("716")
- Spain ("724")
- South Sudan ("728")
- Sudan ("729")
- Western Sahara ("732")
- Suriname ("740")
- Svalbard and Jan Mayen Islands ("744")
- Eswatini ("748")
- Sweden ("752")
- Switzerland ("756")
- Syrian Arab Republic ("760")
- Tajikistan ("762")
- Thailand ("764")
- Togo ("768")
- Tokelau ("772")
- Tonga ("776")
- Trinidad and Tobago ("780")
- United Arab Emirates ("784")
- Tunisia ("788")
- Türkiye ("792")
- Turkmenistan ("795")
- Turks and Caicos Islands ("796")
- Tuvalu ("798")
- Uganda ("800")
- Ukraine ("804")
- North Macedonia ("807")
- Egypt ("818")
- United Kingdom of Great Britain and Northern Ireland ("826")
- Guernsey ("831")
- Jersey ("832")
- Isle of Man ("833")
- United Republic of Tanzania ("834")
- United States of America ("840")
- United States Virgin Islands ("850")
- Burkina Faso ("854")
- Uruguay ("858")
- Uzbekistan ("860")
- Venezuela ("862")
- Wallis and Futuna Islands ("876")
- Samoa ("882")
- Yemen ("887")
- Zambia ("894")

## Special regions: some regions are not represented by UN M49 codes and must be manually constructed using the country regional groupings below

### Countries in the Great Lakes Region (with UN M49 Codes)
- Burundi ("108")
- Democratic Republic of the Congo (DRC) ("180")
- Kenya ("404")
- Rwanda ("646")
- Tanzania ("834")
- Uganda ("800")

### Countries in the Horn of Africa Region (with UN M49 Codes)
- Djibouti ("262")
- Eritrea ("232")
- Ethiopia ("231")
- Somalia ("706")

### Countries in the Sahel Region (with UN M49 Codes)
- Senegal ("686")
- Mauritania ("478")
- Mali ("466")
- Burkina Faso ("854")
- Niger ("562")
- Chad ("148")
- Sudan ("729")

### Countries in the Baltic States (with UN M49 Codes)
- Estonia ("233")
- Latvia ("428")
- Lithuania ("440")

### Countries in the Arctic region (with UN M49 Codes)
- Canada ("124")
- Denmark ("208") (via Greenland and the Faroe Islands)
- Finland ("246")
- Iceland ("352")
- Norway ("578")
- Russian Federation ("643")
- Sweden ("752")
- United States of America ("840") (via Alaska)

### Countries in the Levant region (with UN M49 Codes)
- Cyprus ("196")
- Israel ("376")
- Jordan ("400")
- Lebanon ("422")
- Palestine ("275") (State of Palestine)
- Syria ("760")

### Countries in the Caucasus region (with UN M49 Codes)
- Armenia ("051")
- Azerbaijan ("031")
- Georgia ("268")
- Russian Federation ("643") (via North Caucasus: Chechnya, Dagestan, Ingushetia, etc.)

### Countries in the Balkan region (with UN M49 Codes)
- Albania ("008")
- Bosnia and Herzegovina ("070")
- Bulgaria ("100")
- Montenegro ("499")
- North Macedonia ("807")
- Serbia ("688")

Current list of valid organizations and name: "European Union", "African Union", "G7", "BRICS", "NATO", "ASEAN"


# Schema
{schema}



## Example 1 (Retrieve (all) conflict data based on country or state actor involvement)
Research Question: What conflicts is France involved in as a state party to the conflict?
Generated Query:
////////////////////////////////////////////////////////////////////////
// EXAMPLE 1 (Parametrized Version with Breakdown Counts):
//
// This template retrieves *all* conflicts in which a specific 
// StateActor (identified by UN M49 code) is involved, then breaks 
// them down by classification (IAC, NIAC, and Military Occupation).
//
// To reuse this template, simply modify the top WITH variables:
//   1) target_m49_code     (e.g., "250" for France)
//   2) target_actor_name   (e.g., "France")
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// 0. Setup our dynamic parameters
////////////////////////////////////////////////////////////////////////
WITH 
  "250" AS target_m49_code, 
  "France" AS target_actor_name

////////////////////////////////////////////////////////////////////////
// 1. OPTIONAL MATCH the StateActor for that UN M49 code
//    - If no matching StateActor node is found, 'sa' will be null, 
//      but we keep 1 row to allow a "no conflicts" fallback.
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (sa:StateActor {{UN_M49Code: target_m49_code}})

////////////////////////////////////////////////////////////////////////
// 2. OPTIONAL MATCH any Conflict(s) in which this StateActor is involved
//    - If no conflict is found, 'c' will be null, preserving 1 row.
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c:Conflict)-[:IS_PARTY_TO_CONFLICT]-(sa)

////////////////////////////////////////////////////////////////////////
// 3. OPTIONAL MATCH classifications for each conflict (IAC, NIAC, etc.)
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)

////////////////////////////////////////////////////////////////////////
// 4. OPTIONAL MATCH all other parties to each conflict (state & non-state)
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(actor)

////////////////////////////////////////////////////////////////////////
// 5. Aggregate the conflicts and actors
////////////////////////////////////////////////////////////////////////
WITH 
  // If the actor node wasn't found, default to 'target_actor_name'
  COALESCE(sa.name, target_actor_name) AS country_name,
  COALESCE(COLLECT(DISTINCT c), []) AS conflicts,
  COALESCE(COLLECT(DISTINCT actor), []) AS all_actors,
  COALESCE(COLLECT(DISTINCT {{conflict: c, type: ct.type}}), []) AS conflict_types

////////////////////////////////////////////////////////////////////////
// 6. Compute the total number of conflicts
////////////////////////////////////////////////////////////////////////
WITH 
  country_name,
  conflicts,
  all_actors,
  conflict_types,
  COALESCE(SIZE(conflicts), 0) AS total_conflicts

////////////////////////////////////////////////////////////////////////
// 7. Derive classification breakdown (IAC, NIAC, Occupation)
////////////////////////////////////////////////////////////////////////
WITH
  country_name,
  total_conflicts,
  conflicts,
  all_actors,
  conflict_types,

  // Number of conflicts classified as IAC
  SIZE([
    conf IN conflicts 
    WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "International Armed Conflict (IAC)"}})
    }}
  ]) AS total_IAC,

  // Number of conflicts classified as NIAC
  SIZE([
    conf IN conflicts 
    WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "Non-International Armed Conflict (NIAC)"}})
    }}
  ]) AS total_NIAC,

  // Number of conflicts classified as Military Occupation
  SIZE([
    conf IN conflicts 
    WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "Military Occupation"}})
    }}
  ]) AS total_Military_Occupation,

  // Collect conflict names for each classification
  [conf IN conflicts WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "International Armed Conflict (IAC)"}})
    }} | conf.name
  ] AS IAC_conflict_names,

  [conf IN conflicts WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "Non-International Armed Conflict (NIAC)"}})
    }} | conf.name
  ] AS NIAC_conflict_names,

  [conf IN conflicts WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "Military Occupation"}})
    }} | conf.name
  ] AS Military_Occupation_conflict_names

////////////////////////////////////////////////////////////////////////
// 8. Build a detailed conflict map array
////////////////////////////////////////////////////////////////////////
WITH
  country_name,
  total_conflicts,
  total_IAC,
  total_NIAC,
  total_Military_Occupation,
  IAC_conflict_names,
  NIAC_conflict_names,
  Military_Occupation_conflict_names,
  conflicts,
  all_actors,
  conflict_types,

  [conf IN conflicts |
    {{
      conflict_name: COALESCE(conf.name, "Unknown"),
      conflict_classification: COALESCE(
        [item IN conflict_types WHERE item.conflict = conf | item.type][0], 
        "Unclassified"
      ),
      conflict_overview: COALESCE(conf.overview, "No Overview Available"),
      applicable_ihl_law: COALESCE(conf.applicable_law, "Not Specified"),
      conflict_citation: COALESCE(conf.citation, "No Citation Available"),

      state_parties: CASE
        WHEN SIZE([
          p IN all_actors 
          WHERE "StateActor" IN labels(p) 
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
        ]) = 0 
          THEN "No state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors 
            WHERE "StateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
            | p.name
          ],
          ", "
        )
      END,

      non_state_parties: CASE
        WHEN SIZE([
          p IN all_actors 
          WHERE "NonStateActor" IN labels(p) 
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
        ]) = 0
          THEN "No non-state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors 
            WHERE "NonStateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
            | p.name
          ],
          ", "
        )
      END
    }}
  ] AS conflict_details

////////////////////////////////////////////////////////////////////////
// 9. Build a dynamic summary about the total and classification breakdown
////////////////////////////////////////////////////////////////////////
WITH
  country_name,
  total_conflicts,
  total_IAC,
  total_NIAC,
  total_Military_Occupation,
  IAC_conflict_names,
  NIAC_conflict_names,
  Military_Occupation_conflict_names,
  conflict_details,

  CASE
    WHEN total_conflicts = 0 THEN
      "According to RULAC, there are currently no recorded armed conflicts involving "
      + country_name + " as a state party."
    ELSE
      "According to RULAC, there are currently " + toString(total_conflicts)
      + " total distinct armed conflict(s) involving " + country_name
      + " as a party to conflict. "

      + CASE WHEN total_IAC > 0 THEN 
          toString(total_IAC) + " International Armed Conflict(s) (IAC): " 
          + apoc.text.join(IAC_conflict_names, ", ") + ". "
        ELSE
          ""
        END

      + CASE WHEN total_NIAC > 0 THEN
          toString(total_NIAC) + " Non-International Armed Conflict(s) (NIAC): " 
          + apoc.text.join(NIAC_conflict_names, ", ") + ". "
        ELSE
          ""
        END

      + CASE WHEN total_Military_Occupation > 0 THEN
          toString(total_Military_Occupation) + " Military Occupation(s): " 
          + apoc.text.join(Military_Occupation_conflict_names, ", ") + ". "
        ELSE
          ""
        END
  END AS summary_text

////////////////////////////////////////////////////////////////////////
// 10. Return summary and detailed conflicts as RULAC_research
////////////////////////////////////////////////////////////////////////
RETURN {{
  summary: summary_text,
  conflict_details: CASE
    WHEN total_conflicts = 0 THEN []
    ELSE conflict_details
  END
}} AS RULAC_research



## Example 1A (Reworded) (Retrieve general applicable law (IHL) or conflict data based on country or state actor involvement)
Research Question: What is the applicable IHL or classifications of the conflicts involving the state actor Russia?
Generated Query:
////////////////////////////////////////////////////////////////////////
// EXAMPLE 1 (Parametrized Version with Breakdown Counts):
//
// This template retrieves *all* conflicts in which a specific 
// StateActor (identified by UN M49 code) is involved, then breaks 
// them down by classification (IAC, NIAC, and Military Occupation).
//
// To reuse this template, simply modify the top WITH variables:
//   1) target_m49_code     (e.g., "643" for Russia)
//   2) target_actor_name   (e.g., "Russia")
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// 0. Setup our dynamic parameters
////////////////////////////////////////////////////////////////////////
WITH 
  "643" AS target_m49_code, 
  "Russia" AS target_actor_name

////////////////////////////////////////////////////////////////////////
// 1. OPTIONAL MATCH the StateActor for that UN M49 code
//    - If no matching StateActor node is found, 'sa' will be null, 
//      but we keep 1 row to allow a "no conflicts" fallback.
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (sa:StateActor {{UN_M49Code: target_m49_code}})

////////////////////////////////////////////////////////////////////////
// 2. OPTIONAL MATCH any Conflict(s) in which this StateActor is involved
//    - If no conflict is found, 'c' will be null, preserving 1 row.
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c:Conflict)-[:IS_PARTY_TO_CONFLICT]-(sa)

////////////////////////////////////////////////////////////////////////
// 3. OPTIONAL MATCH classifications for each conflict (IAC, NIAC, etc.)
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)

////////////////////////////////////////////////////////////////////////
// 4. OPTIONAL MATCH all other parties to each conflict (state & non-state)
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(actor)

////////////////////////////////////////////////////////////////////////
// 5. Aggregate the conflicts and actors
////////////////////////////////////////////////////////////////////////
WITH 
  // If the actor node wasn't found, default to 'target_actor_name'
  COALESCE(sa.name, target_actor_name) AS country_name,
  COALESCE(COLLECT(DISTINCT c), []) AS conflicts,
  COALESCE(COLLECT(DISTINCT actor), []) AS all_actors,
  COALESCE(COLLECT(DISTINCT {{conflict: c, type: ct.type}}), []) AS conflict_types

////////////////////////////////////////////////////////////////////////
// 6. Compute the total number of conflicts
////////////////////////////////////////////////////////////////////////
WITH 
  country_name,
  conflicts,
  all_actors,
  conflict_types,
  COALESCE(SIZE(conflicts), 0) AS total_conflicts

////////////////////////////////////////////////////////////////////////
// 7. Derive classification breakdown (IAC, NIAC, Occupation)
////////////////////////////////////////////////////////////////////////
WITH
  country_name,
  total_conflicts,
  conflicts,
  all_actors,
  conflict_types,

  // Number of conflicts classified as IAC
  SIZE([
    conf IN conflicts 
    WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "International Armed Conflict (IAC)"}})
    }}
  ]) AS total_IAC,

  // Number of conflicts classified as NIAC
  SIZE([
    conf IN conflicts 
    WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "Non-International Armed Conflict (NIAC)"}})
    }}
  ]) AS total_NIAC,

  // Number of conflicts classified as Military Occupation
  SIZE([
    conf IN conflicts 
    WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "Military Occupation"}})
    }}
  ]) AS total_Military_Occupation,

  // Collect conflict names for each classification
  [conf IN conflicts WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "International Armed Conflict (IAC)"}})
    }} | conf.name
  ] AS IAC_conflict_names,

  [conf IN conflicts WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "Non-International Armed Conflict (NIAC)"}})
    }} | conf.name
  ] AS NIAC_conflict_names,

  [conf IN conflicts WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "Military Occupation"}})
    }} | conf.name
  ] AS Military_Occupation_conflict_names

////////////////////////////////////////////////////////////////////////
// 8. Build a detailed conflict map array
////////////////////////////////////////////////////////////////////////
WITH
  country_name,
  total_conflicts,
  total_IAC,
  total_NIAC,
  total_Military_Occupation,
  IAC_conflict_names,
  NIAC_conflict_names,
  Military_Occupation_conflict_names,
  conflicts,
  all_actors,
  conflict_types,

  [conf IN conflicts |
    {{
      conflict_name: COALESCE(conf.name, "Unknown"),
      conflict_classification: COALESCE(
        [item IN conflict_types WHERE item.conflict = conf | item.type][0], 
        "Unclassified"
      ),
      conflict_overview: COALESCE(conf.overview, "No Overview Available"),
      applicable_ihl_law: COALESCE(conf.applicable_law, "Not Specified"),
      conflict_citation: COALESCE(conf.citation, "No Citation Available"),

      state_parties: CASE
        WHEN SIZE([
          p IN all_actors 
          WHERE "StateActor" IN labels(p) 
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
        ]) = 0 
          THEN "No state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors 
            WHERE "StateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
            | p.name
          ],
          ", "
        )
      END,

      non_state_parties: CASE
        WHEN SIZE([
          p IN all_actors 
          WHERE "NonStateActor" IN labels(p) 
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
        ]) = 0
          THEN "No non-state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors 
            WHERE "NonStateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
            | p.name
          ],
          ", "
        )
      END
    }}
  ] AS conflict_details

////////////////////////////////////////////////////////////////////////
// 9. Build a dynamic summary about the total and classification breakdown
////////////////////////////////////////////////////////////////////////
WITH
  country_name,
  total_conflicts,
  total_IAC,
  total_NIAC,
  total_Military_Occupation,
  IAC_conflict_names,
  NIAC_conflict_names,
  Military_Occupation_conflict_names,
  conflict_details,

  CASE
    WHEN total_conflicts = 0 THEN
      "According to RULAC, there are currently no recorded armed conflicts involving "
      + country_name + " as a state party."
    ELSE
      "According to RULAC, there are currently " + toString(total_conflicts)
      + " total distinct armed conflict(s) involving " + country_name
      + " as a party to conflict. "

      + CASE WHEN total_IAC > 0 THEN 
          toString(total_IAC) + " International Armed Conflict(s) (IAC): " 
          + apoc.text.join(IAC_conflict_names, ", ") + ". "
        ELSE
          ""
        END

      + CASE WHEN total_NIAC > 0 THEN
          toString(total_NIAC) + " Non-International Armed Conflict(s) (NIAC): " 
          + apoc.text.join(NIAC_conflict_names, ", ") + ". "
        ELSE
          ""
        END

      + CASE WHEN total_Military_Occupation > 0 THEN
          toString(total_Military_Occupation) + " Military Occupation(s): " 
          + apoc.text.join(Military_Occupation_conflict_names, ", ") + ". "
        ELSE
          ""
        END
  END AS summary_text

////////////////////////////////////////////////////////////////////////
// 10. Return summary and detailed conflicts as RULAC_research
////////////////////////////////////////////////////////////////////////
RETURN {{
  summary: summary_text,
  conflict_details: CASE
    WHEN total_conflicts = 0 THEN []
    ELSE conflict_details
  END
}} AS RULAC_research





## Example 1B (Retreive (all) conflict data based on country or state actor involvement) BY CONFLICT TYPE
Research Question: Is India involved in any military occupations? What involvement? 
Generated Query:
////////////////////////////////////////////////////////////////////////
// Example: FILTERING BY COUNTRY (India, UN_M49Code=356) 
//          AND CONFLICT TYPE ("Military Occupation")
// DOUBLE-BRACKET VERSION
////////////////////////////////////////////////////////////////////////

MATCH (sa:StateActor {{UN_M49Code: "356"}})  // India

OPTIONAL MATCH (sa)-[:IS_PARTY_TO_CONFLICT]->(c:Conflict)
  -[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType {{type: "Military Occupation"}})

OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(other_actor)

WITH 
  sa.name AS country_name,
  COLLECT(DISTINCT c) AS conflicts,
  COLLECT(DISTINCT other_actor) AS all_actors

WITH 
  country_name,
  conflicts,
  all_actors,
  COALESCE(SIZE(conflicts), 0) AS total_conflicts

// Collect the conflict names for listing in summary
WITH
  country_name,
  total_conflicts,
  conflicts,
  all_actors,
  [c IN conflicts | c.name] AS conflict_name_list,

  [conflict IN conflicts |
    {{
      conflict_name:          COALESCE(conflict.name, "Unknown"),
      conflict_classification: "Military Occupation",
      conflict_overview:      COALESCE(conflict.overview, "No Overview Available"),
      applicable_ihl_law:     COALESCE(conflict.applicable_law, "Not Specified"),
      conflict_citation:      COALESCE(conflict.citation, "No Citation Available"),

      state_parties: CASE
        WHEN SIZE([
          p IN all_actors
          WHERE "StateActor" IN labels(p) 
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
        ]) = 0 
        THEN "No state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors
            WHERE "StateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
            | p.name
          ], 
          ", "
        )
      END,

      non_state_parties: CASE
        WHEN SIZE([
          p IN all_actors
          WHERE "NonStateActor" IN labels(p) 
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
        ]) = 0
        THEN "No non-state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors
            WHERE "NonStateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
            | p.name
          ], 
          ", "
        )
      END
    }}
  ] AS conflict_details

WITH
  country_name,
  total_conflicts,
  conflict_name_list,
  conflict_details,
  CASE
    WHEN total_conflicts = 0 THEN
      "According to RULAC, there are currently no recorded 'Military Occupation' conflicts involving "
      + country_name + " as a state party."
    ELSE
      "According to RULAC, there are currently " + toString(total_conflicts)
      + " Military Occupation conflict(s) involving " + country_name + " as a state party: " + apoc.text.join(conflict_name_list, ", ") + "."
  END AS summary_text

RETURN {{
  summary: summary_text,
  conflict_details: CASE WHEN total_conflicts = 0 THEN [] ELSE conflict_details END
}} AS RULAC_research



----


## Example 1Ba (Reworded)(Retreive (all) conflict data based on country or state actor involvement) BY CONFLICT TYPE
Research Question:  What are the non-international armed conflicts involving Ethiopia? 
Generated Query:
////////////////////////////////////////////////////////////////////////
// EXAMPLE 1Ba (Parametrized & Filtered by Conflict Type):
//
// This template retrieves all conflicts of a specific type (e.g., NIAC) 
// involving a particular StateActor (by UN M49 code). Then it returns 
// a summary and detailed conflict info (overview, law, parties, etc.).
//
// To reuse this template, change the top WITH variables:
//   1) target_m49_code       (e.g., "231" for Ethiopia)
//   2) target_actor_name     (e.g., "Ethiopia")
//   3) target_conflict_type  (e.g., "Non-International Armed Conflict (NIAC)")
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// 0. Set up our parameters
////////////////////////////////////////////////////////////////////////
WITH 
  "231" AS target_m49_code, 
  "Ethiopia" AS target_actor_name,
  "Non-International Armed Conflict (NIAC)" AS target_conflict_type

////////////////////////////////////////////////////////////////////////
// 1. OPTIONAL MATCH the StateActor node with the given M49 code
//    (If no node found, sa=null, but we still keep one row for fallback)
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (sa:StateActor {{UN_M49Code: target_m49_code}})

////////////////////////////////////////////////////////////////////////
// 2. OPTIONAL MATCH conflicts that involve this StateActor 
//    AND are classified as our target conflict type. 
//    - If none, c = null (still 1 row to show "no conflicts" in summary).
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (sa)-[:IS_PARTY_TO_CONFLICT]->(c:Conflict)
       -[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)
WHERE ct.type = target_conflict_type

////////////////////////////////////////////////////////////////////////
// 3. OPTIONAL MATCH other actors involved in these conflicts
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(other_actor)

////////////////////////////////////////////////////////////////////////
// 4. Aggregate the conflicts and actors
////////////////////////////////////////////////////////////////////////
WITH
  COALESCE(sa.name, target_actor_name) AS country_name,
  COLLECT(DISTINCT c) AS conflicts,
  COLLECT(DISTINCT other_actor) AS all_actors,
  target_conflict_type AS classification

////////////////////////////////////////////////////////////////////////
// 5. Determine how many conflicts exist; build a conflict name list
////////////////////////////////////////////////////////////////////////
WITH
  country_name,
  conflicts,
  all_actors,
  classification,
  COALESCE(SIZE(conflicts), 0) AS total_conflicts,
  [conflict IN conflicts | conflict.name] AS conflict_name_list

////////////////////////////////////////////////////////////////////////
// 6. Build the detailed conflict array
////////////////////////////////////////////////////////////////////////
WITH
  country_name,
  total_conflicts,
  classification,
  conflict_name_list,
  conflicts,
  all_actors,

  // Construct a map of each conflict's details
  [conflict IN conflicts |
    {{
      conflict_name: COALESCE(conflict.name, "Unknown"),
      conflict_classification: classification,
      conflict_overview: COALESCE(conflict.overview, "No Overview Available"),
      applicable_ihl_law: COALESCE(conflict.applicable_law, "Not Specified"),
      conflict_citation: COALESCE(conflict.citation, "No Citation Available"),

      state_parties: CASE
        WHEN SIZE([
          p IN all_actors
          WHERE "StateActor" IN labels(p) 
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
        ]) = 0
          THEN "No state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors
            WHERE "StateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
            | p.name
          ],
          ", "
        )
      END,

      non_state_parties: CASE
        WHEN SIZE([
          p IN all_actors
          WHERE "NonStateActor" IN labels(p) 
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
        ]) = 0
          THEN "No non-state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors
            WHERE "NonStateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
            | p.name
          ],
          ", "
        )
      END
    }}
  ] AS conflict_details

////////////////////////////////////////////////////////////////////////
// 7. Build a dynamic summary 
////////////////////////////////////////////////////////////////////////
WITH
  country_name,
  total_conflicts,
  classification,
  conflict_name_list,
  conflict_details,

  CASE
    WHEN total_conflicts = 0 THEN
      "According to RULAC, there are currently no recorded '"
      + classification + "' conflicts involving "
      + country_name + " as a state party."
    ELSE
      "According to RULAC, there are currently "
      + toString(total_conflicts) + " '"
      + classification + "' conflict(s) involving "
      + country_name + " as a state party: "
      + apoc.text.join(conflict_name_list, ", ") + "."
  END AS summary_text

////////////////////////////////////////////////////////////////////////
// 8. Return our final structured object as RULAC_research
////////////////////////////////////////////////////////////////////////
RETURN {{
  summary: summary_text,
  conflict_details: CASE
    WHEN total_conflicts = 0 THEN []
    ELSE conflict_details
  END
}} AS RULAC_research



Example 2: Retrieve Conflict Data (name, classification, overview, applicable IHL, parties) for Conflict(s) Taking Place in a Specific Country or Region
Research Question:(s) What conflicts are currently taking place or happening in South Africa?
Generated Query:
////////////////////////////////////////////////////////////////////////
// EXAMPLE 2 (Parametrized Version with Breakdown Counts):
// 
// This template retrieves all conflicts happening in a specific country
// or region (by UN M49 code), then breaks down the total conflicts by
// classification: IAC, NIAC, or Military Occupation.
//
// You can reuse this template by modifying the top WITH variables:
//   1) target_m49_code        (e.g., "710" for South Africa)
//   2) target_country_name    (e.g., "South Africa")
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// 0. Setup our dynamic parameters
////////////////////////////////////////////////////////////////////////
WITH 
  "710" AS target_m49_code,
  "South Africa" AS target_country_name

////////////////////////////////////////////////////////////////////////
// 1. OPTIONAL MATCH the target country by UN M49 code
//    - If not found, 'co' will be null, but we still keep a row 
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (co:Country {{UN_M49Code: target_m49_code}})

////////////////////////////////////////////////////////////////////////
// 2. OPTIONAL MATCH conflicts that take place in that country
//    - If no conflict is found, 'c' is null (one row retained)
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c:Conflict)-[:IS_TAKING_PLACE_IN_COUNTRY]->(co)

////////////////////////////////////////////////////////////////////////
// 3. OPTIONAL MATCH the classification (IAC, NIAC, etc.) of these conflicts
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)

////////////////////////////////////////////////////////////////////////
// 4. OPTIONAL MATCH any involved actors (state or non-state)
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(actor)

////////////////////////////////////////////////////////////////////////
// 5. Aggregate all data
////////////////////////////////////////////////////////////////////////
WITH
  // If country is null, use our fallback name
  COALESCE(co.name, target_country_name) AS country_name,
  COALESCE(COLLECT(DISTINCT c), []) AS conflicts,
  COALESCE(COLLECT(DISTINCT actor), []) AS all_actors,
  // Capture (conflict, ct.type) pairs for classification reference
  COALESCE(COLLECT(DISTINCT {{conflict: c, type: ct.type}}), []) AS conflict_types

////////////////////////////////////////////////////////////////////////
// 6. Count total conflicts (ensure 'conflicts' is not null)
////////////////////////////////////////////////////////////////////////
WITH
  country_name,
  conflicts,
  all_actors,
  conflict_types,
  COALESCE(SIZE(conflicts), 0) AS total_conflicts

////////////////////////////////////////////////////////////////////////
// 7. Compute classification breakdown
////////////////////////////////////////////////////////////////////////
WITH
  country_name,
  total_conflicts,
  conflicts,
  all_actors,
  conflict_types,

  // Count how many conflicts are "IAC"
  SIZE([
    conf IN conflicts 
    WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "International Armed Conflict (IAC)"}})
    }}
  ]) AS total_IAC,

  // Count how many are "NIAC"
  SIZE([
    conf IN conflicts 
    WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "Non-International Armed Conflict (NIAC)"}})
    }}
  ]) AS total_NIAC,

  // Count how many are "Military Occupation"
  SIZE([
    conf IN conflicts 
    WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "Military Occupation"}})
    }}
  ]) AS total_Military_Occupation,

  // Collect names for each classification
  [conf IN conflicts WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "International Armed Conflict (IAC)"}})
    }} | conf.name
  ] AS IAC_conflict_names,

  [conf IN conflicts WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "Non-International Armed Conflict (NIAC)"}})
    }} | conf.name
  ] AS NIAC_conflict_names,

  [conf IN conflicts WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "Military Occupation"}})
    }} | conf.name
  ] AS Military_Occupation_conflict_names

////////////////////////////////////////////////////////////////////////
// 8. Build detailed conflict profiles, referencing 'conflict_types'
////////////////////////////////////////////////////////////////////////
WITH
  country_name,
  total_conflicts,
  total_IAC,
  total_NIAC,
  total_Military_Occupation,
  IAC_conflict_names,
  NIAC_conflict_names,
  Military_Occupation_conflict_names,
  conflicts,
  all_actors,
  conflict_types,

  // Build a map for each conflict
  [conf IN conflicts |
    {{
      conflict_name: COALESCE(conf.name, "Unknown"),
      conflict_classification: COALESCE(
        [item IN conflict_types WHERE item.conflict = conf | item.type][0], 
        "Unclassified"
      ),
      conflict_overview: COALESCE(conf.overview, "No Overview Available"),
      applicable_ihl_law: COALESCE(conf.applicable_law, "Not Specified"),
      conflict_citation: COALESCE(conf.citation, "No Citation Available"),

      state_parties: CASE
        WHEN size([
          p IN all_actors 
          WHERE "StateActor" IN labels(p)
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
        ]) = 0
          THEN "No state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors 
            WHERE "StateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
            | p.name
          ], 
          ", "
        )
      END,

      non_state_parties: CASE
        WHEN size([
          p IN all_actors 
          WHERE "NonStateActor" IN labels(p)
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
        ]) = 0
          THEN "No non-state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors 
            WHERE "NonStateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
            | p.name
          ],
          ", "
        )
      END
    }}
  ] AS conflict_details

////////////////////////////////////////////////////////////////////////
// 9. Construct the dynamic, human-readable summary
////////////////////////////////////////////////////////////////////////
WITH
  country_name,
  total_conflicts,
  total_IAC,
  total_NIAC,
  total_Military_Occupation,
  IAC_conflict_names,
  NIAC_conflict_names,
  Military_Occupation_conflict_names,
  conflict_details,

  CASE
    WHEN total_conflicts = 0 THEN
      "According to RULAC, there are currently no recorded armed conflicts taking place in "
      + country_name + "."
    ELSE
      "According to RULAC, there are currently " 
      + toString(total_conflicts)
      + " total distinct armed conflict(s) taking place in "
      + country_name + ". "

      // IAC section if present
      + CASE WHEN total_IAC > 0 THEN 
          toString(total_IAC) + " International Armed Conflict(s) (IAC): "
          + apoc.text.join(IAC_conflict_names, ", ") + ". "
        ELSE 
          ""
        END

      // NIAC section if present
      + CASE WHEN total_NIAC > 0 THEN 
          toString(total_NIAC) + " Non-International Armed Conflict(s) (NIAC): "
          + apoc.text.join(NIAC_conflict_names, ", ") + ". "
        ELSE 
          ""
        END

      // Military Occupation section if present
      + CASE WHEN total_Military_Occupation > 0 THEN 
          toString(total_Military_Occupation) + " Military Occupation(s): "
          + apoc.text.join(Military_Occupation_conflict_names, ", ") + ". "
        ELSE 
          ""
        END
  END AS summary_text

////////////////////////////////////////////////////////////////////////
// 10. Return the final structured object as RULAC_research
////////////////////////////////////////////////////////////////////////
RETURN {{
  summary: summary_text,
  conflict_details: CASE 
    WHEN total_conflicts = 0 THEN []
    ELSE conflict_details
  END
}} AS RULAC_research




Example 2b: Retrieve Conflict Data (name, classification, overview, applicable IHL, parties) for Conflict(s) Taking Place in a Specific Country or Region AND filtered by conflict type
Research Question:(s) Which international armed conflicts are ongoing in Mali?
Generated Query:
////////////////////////////////////////////////////////////////////////
// EXAMPLE 2b (Parametrized Version):
// 
// This template retrieves all conflicts of a certain classification
// ("target_conflict_type") taking place in a country defined by
// "target_m49_code" and "target_country_name". 
//
// You can reuse this template by changing the three WITH variables:
//   1) target_m49_code        (e.g., "466" for Mali)
//   2) target_country_name    (e.g., "Mali")
//   3) target_conflict_type   (e.g., "International Armed Conflict (IAC)")
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// 0. Setup our dynamic parameters
////////////////////////////////////////////////////////////////////////
WITH 
  "466" AS target_m49_code, 
  "Mali" AS target_country_name,
  "International Armed Conflict (IAC)" AS target_conflict_type

////////////////////////////////////////////////////////////////////////
// 1. OPTIONAL MATCH the target country. We use OPTIONAL MATCH so that 
//    if the country doesn't exist, we still keep a row of data with 
//    co = null. 
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (co:Country {{UN_M49Code: target_m49_code}})

////////////////////////////////////////////////////////////////////////
// 2. OPTIONAL MATCH conflicts in that country which have the given
//    classification. Again, OPTIONAL so that if none match, c = null 
//    (rather than losing all rows).
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH 
  (co)<-[:IS_TAKING_PLACE_IN_COUNTRY]-(c:Conflict)
    -[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)
WHERE ct.type = target_conflict_type

////////////////////////////////////////////////////////////////////////
// 3. OPTIONAL MATCH any state or non-state actors to these conflicts
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(actor)

////////////////////////////////////////////////////////////////////////
// 4. Aggregate the conflicts and actors
////////////////////////////////////////////////////////////////////////
WITH 
  // If 'co' is null, use the fallback target_country_name
  COALESCE(co.name, target_country_name) AS country_name,
  COALESCE(COLLECT(DISTINCT c), []) AS conflicts,
  COALESCE(COLLECT(DISTINCT actor), []) AS all_actors,
  target_conflict_type AS classification

////////////////////////////////////////////////////////////////////////
// 5. Calculate how many conflicts matched, and handle no-results logic
////////////////////////////////////////////////////////////////////////
WITH 
  country_name, 
  conflicts, 
  all_actors, 
  classification,
  COALESCE(SIZE(conflicts), 0) AS total_conflicts

////////////////////////////////////////////////////////////////////////
// 6. Build a detailed structure for each conflict
////////////////////////////////////////////////////////////////////////
WITH
  country_name,
  total_conflicts,
  classification,
  [conflict IN conflicts | conflict.name] AS conflict_name_list,

  [conflict IN conflicts |
    {{
      conflict_name: COALESCE(conflict.name, "Unknown"),
      conflict_classification: classification,
      conflict_overview: COALESCE(conflict.overview, "No Overview Available"),
      applicable_ihl_law: COALESCE(conflict.applicable_law, "Not Specified"),
      conflict_citation: COALESCE(conflict.citation, "No Citation Available"),

      // State parties
      state_parties: CASE
        WHEN SIZE([
          p IN all_actors 
          WHERE "StateActor" IN labels(p)
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
        ]) = 0 
          THEN "No state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors
            WHERE "StateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
            | p.name
          ],
          ", "
        )
      END,

      // Non-state parties
      non_state_parties: CASE
        WHEN SIZE([
          p IN all_actors 
          WHERE "NonStateActor" IN labels(p)
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
        ]) = 0
          THEN "No non-state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors
            WHERE "NonStateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
            | p.name
          ], 
          ", "
        )
      END
    }}
  ] AS conflict_details

////////////////////////////////////////////////////////////////////////
// 7. Construct the human-readable summary
////////////////////////////////////////////////////////////////////////
WITH
  country_name,
  total_conflicts,
  classification,
  conflict_name_list,
  conflict_details,

  CASE
    WHEN total_conflicts = 0 THEN
      "According to RULAC, there are currently no recorded '"
      + classification + "' conflicts taking place in " + country_name + "."
    ELSE
      "According to RULAC, there are currently " 
      + toString(total_conflicts) + " '"
      + classification + "' conflict(s) taking place in "
      + country_name + ": " + apoc.text.join(conflict_name_list, ", ") + "."
  END AS summary_text

////////////////////////////////////////////////////////////////////////
// 8. Return as a structured object named RULAC_research
////////////////////////////////////////////////////////////////////////
RETURN {{
  summary: summary_text,
  conflict_details: CASE 
    WHEN total_conflicts = 0 THEN [] 
    ELSE conflict_details 
  END
}} AS RULAC_research



Example 2b (REWORDED): Retrieve specific Conflict Data (name, classification, overview, applicable IHL, parties) for Conflict(s) Taking Place in a Specific Country or Region AND filtered by conflict type
Research Question:(s) What military occupations are currently happening in Afghanistan?
Generated Query:
////////////////////////////////////////////////////////////////////////
// EXAMPLE 2b (Parametrized Version):
// 
// This template retrieves all conflicts of a certain classification
// ("target_conflict_type") taking place in a country defined by
// "target_m49_code" and "target_country_name". 
//
// You can reuse this template by changing the three WITH variables:
//   1) target_m49_code        (e.g., "466" for Mali)
//   2) target_country_name    (e.g., "Mali")
//   3) target_conflict_type   (e.g., "International Armed Conflict (IAC)")
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// 0. Setup our dynamic parameters
////////////////////////////////////////////////////////////////////////
WITH 
  "004" AS target_m49_code, 
  "Afghanistan" AS target_country_name,
  "Military Occupation" AS target_conflict_type

////////////////////////////////////////////////////////////////////////
// 1. OPTIONAL MATCH the target country. We use OPTIONAL MATCH so that 
//    if the country doesn't exist, we still keep a row of data with 
//    co = null. 
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (co:Country {{UN_M49Code: target_m49_code}})

////////////////////////////////////////////////////////////////////////
// 2. OPTIONAL MATCH conflicts in that country which have the given
//    classification. Again, OPTIONAL so that if none match, c = null 
//    (rather than losing all rows).
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH 
  (co)<-[:IS_TAKING_PLACE_IN_COUNTRY]-(c:Conflict)
    -[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)
WHERE ct.type = target_conflict_type

////////////////////////////////////////////////////////////////////////
// 3. OPTIONAL MATCH any state or non-state actors to these conflicts
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(actor)

////////////////////////////////////////////////////////////////////////
// 4. Aggregate the conflicts and actors
////////////////////////////////////////////////////////////////////////
WITH 
  // If 'co' is null, use the fallback target_country_name
  COALESCE(co.name, target_country_name) AS country_name,
  COALESCE(COLLECT(DISTINCT c), []) AS conflicts,
  COALESCE(COLLECT(DISTINCT actor), []) AS all_actors,
  target_conflict_type AS classification

////////////////////////////////////////////////////////////////////////
// 5. Calculate how many conflicts matched, and handle no-results logic
////////////////////////////////////////////////////////////////////////
WITH 
  country_name, 
  conflicts, 
  all_actors, 
  classification,
  COALESCE(SIZE(conflicts), 0) AS total_conflicts

////////////////////////////////////////////////////////////////////////
// 6. Build a detailed structure for each conflict
////////////////////////////////////////////////////////////////////////
WITH
  country_name,
  total_conflicts,
  classification,
  [conflict IN conflicts | conflict.name] AS conflict_name_list,

  [conflict IN conflicts |
    {{
      conflict_name: COALESCE(conflict.name, "Unknown"),
      conflict_classification: classification,
      conflict_overview: COALESCE(conflict.overview, "No Overview Available"),
      applicable_ihl_law: COALESCE(conflict.applicable_law, "Not Specified"),
      conflict_citation: COALESCE(conflict.citation, "No Citation Available"),

      // State parties
      state_parties: CASE
        WHEN SIZE([
          p IN all_actors 
          WHERE "StateActor" IN labels(p)
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
        ]) = 0 
          THEN "No state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors
            WHERE "StateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
            | p.name
          ],
          ", "
        )
      END,

      // Non-state parties
      non_state_parties: CASE
        WHEN SIZE([
          p IN all_actors 
          WHERE "NonStateActor" IN labels(p)
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
        ]) = 0
          THEN "No non-state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors
            WHERE "NonStateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
            | p.name
          ], 
          ", "
        )
      END
    }}
  ] AS conflict_details

////////////////////////////////////////////////////////////////////////
// 7. Construct the human-readable summary
////////////////////////////////////////////////////////////////////////
WITH
  country_name,
  total_conflicts,
  classification,
  conflict_name_list,
  conflict_details,

  CASE
    WHEN total_conflicts = 0 THEN
      "According to RULAC, there are currently no recorded '"
      + classification + "' conflicts taking place in " + country_name + "."
    ELSE
      "According to RULAC, there are currently " 
      + toString(total_conflicts) + " '"
      + classification + "' conflict(s) taking place in "
      + country_name + ": " + apoc.text.join(conflict_name_list, ", ") + "."
  END AS summary_text

////////////////////////////////////////////////////////////////////////
// 8. Return as a structured object named RULAC_research
////////////////////////////////////////////////////////////////////////
RETURN {{
  summary: summary_text,
  conflict_details: CASE 
    WHEN total_conflicts = 0 THEN [] 
    ELSE conflict_details 
  END
}} AS RULAC_research




Example 4 : Comparing Two States' Conflicts
Research Question: Are there more conflicts involving Ukraine or Saudi Arabia as state actors?
Generated Query:
////////////////////////////////////////////////////////////////////////
// EXAMPLE 6a (Parametrized & Comparing Two States' Conflicts):
//
// This template compares the conflicts of exactly two different 
// StateActor nodes, identified by a list of UN M49 codes (e.g. Ukraine 
// "804" and Saudi Arabia "682"). 
// 
// 1) We define an array of two M49 codes at the top (target_m49_codes).
// 2) We MATCH all StateActor nodes whose UN_M49Code is in that array.
// 3) For each matched state, we OPTIONAL MATCH the conflicts and 
//    collect relevant details (classification, parties, etc.).
// 4) We aggregate the data by state and build a dynamic comparison 
//    summary at the end.
// 
// To reuse this template, simply adjust the 'target_m49_codes' array 
// (and optionally rename the states in your database). 
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// 0. Setup parameters: the two UN M49 codes to compare
////////////////////////////////////////////////////////////////////////
WITH ["804", "682"] AS target_m49_codes
  // e.g. 804 = Ukraine, 682 = Saudi Arabia
////////////////////////////////////////////////////////////////////////
// 1. MATCH any StateActor nodes whose UN_M49Code is in our array. 
//    - If only one or zero states match, we'll handle that later.
////////////////////////////////////////////////////////////////////////
MATCH (sa:StateActor)
WHERE sa.UN_M49Code IN target_m49_codes

////////////////////////////////////////////////////////////////////////
// 2. OPTIONAL MATCH to gather conflicts for each state. 
//    - If a state has no conflicts, c = null, but we still keep a row.
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (sa)-[:IS_PARTY_TO_CONFLICT]->(c:Conflict)

////////////////////////////////////////////////////////////////////////
// 3. OPTIONAL MATCH conflict classification (ct) and other actors. 
//    - Each conflict can have 0..N conflict types, 0..N actor parties.
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)
OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(actor)

////////////////////////////////////////////////////////////////////////
// 4. AGGREGATE these at the state level. Each row now represents 
//    one unique StateActor, with:
//      - conflict_list: all distinct conflicts 
//      - all_actors: all distinct actors across those conflicts
//      - conflict_type_pairs: all conflict, classification pairs
////////////////////////////////////////////////////////////////////////
WITH 
  sa,
  COLLECT(DISTINCT c) AS conflict_list,
  COLLECT(DISTINCT actor) AS all_actors,
  COLLECT(DISTINCT {{conflict: c, type: ct.type}}) AS conflict_type_pairs

////////////////////////////////////////////////////////////////////////
// 5. For each StateActor, calculate the total number of conflicts 
//    and build a list of conflict names. 
////////////////////////////////////////////////////////////////////////
WITH
  sa,
  conflict_list,
  all_actors,
  conflict_type_pairs,
  SIZE(conflict_list) AS total_conflicts,
  [conf IN conflict_list | conf.name] AS conflict_names

////////////////////////////////////////////////////////////////////////
// 6. Build a detailed map for each conflict in conflict_list, 
//    including classification, overview, parties, etc.
////////////////////////////////////////////////////////////////////////
WITH
  sa,
  total_conflicts,
  conflict_names,
  all_actors,
  conflict_type_pairs,

  // "conflicts_per_state" is an array of conflict detail maps
  [conf IN conflict_list |
    {{
      conflict_name: COALESCE(conf.name, "Unknown"),
      conflict_classification: COALESCE(
        // Find exactly one classification label for this conflict
        [pair IN conflict_type_pairs WHERE pair.conflict = conf | pair.type][0],
        "Unclassified"
      ),
      conflict_overview: COALESCE(conf.overview, "No Overview Available"),
      applicable_ihl_law: COALESCE(conf.applicable_law, "Not Specified"),
      conflict_citation: COALESCE(conf.citation, "No Citation Available"),

      // State parties to this conflict
      state_parties: CASE
        WHEN SIZE([
          p IN all_actors
          WHERE "StateActor" IN labels(p)
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
        ]) = 0
          THEN "No state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors
            WHERE "StateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
            | p.name
          ],
          ", "
        )
      END,

      // Non-state parties to this conflict
      non_state_parties: CASE
        WHEN SIZE([
          p IN all_actors
          WHERE "NonStateActor" IN labels(p)
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
        ]) = 0
          THEN "No non-state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors
            WHERE "NonStateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
            | p.name
          ],
          ", "
        )
      END
    }}
  ] AS conflicts_per_state

////////////////////////////////////////////////////////////////////////
// 7. Build a map of each state's data and collect those maps 
//    into an array for final comparison.
////////////////////////////////////////////////////////////////////////
WITH 
  COLLECT({{
    state_name: sa.name,
    state_UN_M49Code: sa.UN_M49Code,
    total_conflicts: total_conflicts,
    conflict_names: conflict_names,
    conflicts_per_state: conflicts_per_state
  }}) AS state_conflict_summary

////////////////////////////////////////////////////////////////////////
// 8. Flatten all conflict details for the final return object, 
//    and extract the first and second state's data for direct comparison.
////////////////////////////////////////////////////////////////////////
WITH
  state_conflict_summary,
  apoc.coll.flatten(
    [st IN state_conflict_summary | st.conflicts_per_state]
  ) AS conflict_details,
  state_conflict_summary[0] AS state_1_data,
  state_conflict_summary[1] AS state_2_data

////////////////////////////////////////////////////////////////////////
// 9. Construct the dynamic summary that compares the total_conflicts 
//    of state_1_data vs. state_2_data. Handle scenarios:
//     - If <2 states
//     - If neither has conflicts
//     - If only one has conflicts
//     - If both do, check which has more
//     - Or same count
////////////////////////////////////////////////////////////////////////
RETURN {{
  summary: CASE 
    WHEN size(state_conflict_summary) < 2 THEN
      "Insufficient data to compare conflicts for the requested states."
    WHEN state_1_data.total_conflicts = 0
      AND state_2_data.total_conflicts = 0 THEN
      "According to RULAC, neither " 
      + state_1_data.state_name + " nor " 
      + state_2_data.state_name 
      + " are currently party to any conflicts."
    WHEN state_1_data.total_conflicts = 0 THEN
      "According to RULAC, " + state_1_data.state_name 
      + " is not currently party to any conflicts. Meanwhile, " 
      + state_2_data.state_name + " is a state party to " 
      + toString(state_2_data.total_conflicts) + " total conflicts: " 
      + apoc.text.join(state_2_data.conflict_names, ", ") + "."
    WHEN state_2_data.total_conflicts = 0 THEN
      "According to RULAC, " + state_2_data.state_name 
      + " is not currently party to any conflicts. Meanwhile, " 
      + state_1_data.state_name + " is a state party to " 
      + toString(state_1_data.total_conflicts) + " total conflicts: " 
      + apoc.text.join(state_1_data.conflict_names, ", ") + "."
    WHEN state_1_data.total_conflicts > state_2_data.total_conflicts THEN 
      "According to RULAC, in a comparison between " 
      + state_1_data.state_name + " and " + state_2_data.state_name 
      + ", the state currently party to the most distinct armed conflicts is " 
      + state_1_data.state_name + ", being a state party to " 
      + toString(state_1_data.total_conflicts) + " total conflicts: " 
      + apoc.text.join(state_1_data.conflict_names, ", ") + ". Meanwhile, " 
      + state_2_data.state_name + " is a state party to " 
      + toString(state_2_data.total_conflicts) + " total conflicts: " 
      + apoc.text.join(state_2_data.conflict_names, ", ") + "."
    WHEN state_2_data.total_conflicts > state_1_data.total_conflicts THEN
      "According to RULAC, in a comparison between " 
      + state_1_data.state_name + " and " + state_2_data.state_name 
      + ", the state currently party to the most distinct armed conflicts is " 
      + state_2_data.state_name + ", being a state party to " 
      + toString(state_2_data.total_conflicts) + " total conflicts: " 
      + apoc.text.join(state_2_data.conflict_names, ", ") + ". Meanwhile, " 
      + state_1_data.state_name + " is a state party to " 
      + toString(state_1_data.total_conflicts) + " total conflicts: " 
      + apoc.text.join(state_1_data.conflict_names, ", ") + "."
    ELSE
      // same number of conflicts for both
      "According to RULAC, in a comparison between " 
      + state_1_data.state_name + " and " + state_2_data.state_name 
      + ", both states are equally party to " 
      + toString(state_1_data.total_conflicts) + " total conflicts. " 
      + state_1_data.state_name + " is party to: " 
      + apoc.text.join(state_1_data.conflict_names, ", ") + ". " 
      + state_2_data.state_name + " is party to: " 
      + apoc.text.join(state_2_data.conflict_names, ", ") + "."
  END,

  // Flattened conflict details for both states
  conflict_details: conflict_details

}} AS RULAC_research






Example 4b : Comparing Two States' Conflicts by Conflict type classification
Research Question:  Which country has participated in more military occupations—Israel or Russia?
Generated Query:
////////////////////////////////////////////////////////////////////////
// EXAMPLE: Comparing Two States' Conflicts by Conflict Type
//
// This template compares the conflicts of exactly two different
// StateActor nodes, identified by a list of UN M49 codes (e.g. Israel
// "376" and Russia "643"), and filters by a specific conflict type
// (e.g., "Military Occupation").
//
// 1) We define an array of two M49 codes at the top (target_m49_codes).
// 2) We MATCH all StateActor nodes whose UN_M49Code is in that array.
// 3) For each matched state, we OPTIONAL MATCH the conflicts and
//    collect relevant details (classification, parties, etc.).
// 4) We aggregate the data by state and build a dynamic comparison
//    summary at the end.
//
// To reuse this template, simply adjust the 'target_m49_codes' array
// and the 'target_conflict_type' variable.
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// 0. Setup parameters: the two UN M49 codes to compare and the conflict type
////////////////////////////////////////////////////////////////////////
WITH ["376", "643"] AS target_m49_codes,
     "Military Occupation" AS target_conflict_type

////////////////////////////////////////////////////////////////////////
// 1. MATCH any StateActor nodes whose UN_M49Code is in our array.
////////////////////////////////////////////////////////////////////////
MATCH (sa:StateActor)
WHERE sa.UN_M49Code IN target_m49_codes

////////////////////////////////////////////////////////////////////////
// 2. OPTIONAL MATCH to gather conflicts for each state.
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (sa)-[:IS_PARTY_TO_CONFLICT]->(c:Conflict)
       -[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)
WHERE ct.type = target_conflict_type

////////////////////////////////////////////////////////////////////////
// 3. OPTIONAL MATCH all other parties to these conflicts.
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(actor)

////////////////////////////////////////////////////////////////////////
// 4. AGGREGATE these at the state level. Each row now represents
//    one unique StateActor, with:
//      - conflict_list: all distinct conflicts
//      - all_actors: all distinct actors across those conflicts
//      - conflict_type_pairs: all conflict, classification pairs
////////////////////////////////////////////////////////////////////////
WITH
  sa,
  target_conflict_type,
  COLLECT(DISTINCT c) AS conflict_list,
  COLLECT(DISTINCT actor) AS all_actors,
  COLLECT(DISTINCT {{conflict: c, type: ct.type}}) AS conflict_type_pairs

////////////////////////////////////////////////////////////////////////
// 5. For each StateActor, calculate the total number of conflicts
//    and build a list of conflict names.
////////////////////////////////////////////////////////////////////////
WITH
  sa,
  target_conflict_type,
  conflict_list,
  all_actors,
  conflict_type_pairs,
  SIZE(conflict_list) AS total_conflicts,
  [conf IN conflict_list | conf.name] AS conflict_names

////////////////////////////////////////////////////////////////////////
// 6. Build a detailed map for each conflict in conflict_list,
//    including classification, overview, parties, etc.
////////////////////////////////////////////////////////////////////////
WITH
  sa,
  target_conflict_type,
  total_conflicts,
  conflict_names,
  all_actors,
  conflict_type_pairs,

  // "conflicts_per_state" is an array of conflict detail maps
  [conf IN conflict_list |
    {{
      conflict_name: COALESCE(conf.name, "Unknown"),
      conflict_classification: COALESCE(
        // Find exactly one classification label for this conflict
        [pair IN conflict_type_pairs WHERE pair.conflict = conf | pair.type][0],
        "Unclassified"
      ),
      conflict_overview: COALESCE(conf.overview, "No Overview Available"),
      applicable_ihl_law: COALESCE(conf.applicable_law, "Not Specified"),
      conflict_citation: COALESCE(conf.citation, "No Citation Available"),

      // State parties to this conflict
      state_parties: CASE
        WHEN SIZE([
          p IN all_actors
          WHERE "StateActor" IN labels(p)
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
        ]) = 0
          THEN "No state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors
            WHERE "StateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
            | p.name
          ],
          ", "
        )
      END,

      // Non-state parties to this conflict
      non_state_parties: CASE
        WHEN SIZE([
          p IN all_actors
          WHERE "NonStateActor" IN labels(p)
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
        ]) = 0
          THEN "No non-state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors
            WHERE "NonStateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
            | p.name
          ],
          ", "
        )
      END
    }}
  ] AS conflicts_per_state

////////////////////////////////////////////////////////////////////////
// 7. Build a map of each state's data and collect those maps
//    into an array for final comparison.
////////////////////////////////////////////////////////////////////////
WITH
  COLLECT({{
    state_name: sa.name,
    state_UN_M49Code: sa.UN_M49Code,
    total_conflicts: total_conflicts,
    conflict_names: conflict_names,
    conflicts_per_state: conflicts_per_state
  }}) AS state_conflict_summary,
  target_conflict_type

////////////////////////////////////////////////////////////////////////
// 8. Flatten all conflict details for the final return object,
//    and extract the first and second state's data for direct comparison.
////////////////////////////////////////////////////////////////////////
WITH
  state_conflict_summary,
  target_conflict_type,
  apoc.coll.flatten(
    [st IN state_conflict_summary | st.conflicts_per_state]
  ) AS conflict_details,
  state_conflict_summary[0] AS state_1_data,
  state_conflict_summary[1] AS state_2_data

////////////////////////////////////////////////////////////////////////
// 9. Construct the dynamic summary that compares the total_conflicts
//    of state_1_data vs. state_2_data. Handle scenarios:
//     - If <2 states
//     - If neither has conflicts
//     - If only one has conflicts
//     - If both do, check which has more
//     - Or same count
////////////////////////////////////////////////////////////////////////
RETURN {{
  summary: CASE
    WHEN size(state_conflict_summary) < 2 THEN
      "Insufficient data to compare conflicts for the requested states."
    WHEN state_1_data.total_conflicts = 0
      AND state_2_data.total_conflicts = 0 THEN
      "According to RULAC, neither "
      + state_1_data.state_name + " nor "
      + state_2_data.state_name
      + " are currently party to any '" + target_conflict_type + "' conflicts."
    WHEN state_1_data.total_conflicts = 0 THEN
      "According to RULAC, " + state_1_data.state_name
      + " is not currently party to any '" + target_conflict_type + "' conflicts. Meanwhile, "
      + state_2_data.state_name + " is a state party to "
      + toString(state_2_data.total_conflicts) + " total '" + target_conflict_type + "' conflicts: "
      + apoc.text.join(state_2_data.conflict_names, ", ") + "."
    WHEN state_2_data.total_conflicts = 0 THEN
      "According to RULAC, " + state_2_data.state_name
      + " is not currently party to any '" + target_conflict_type + "' conflicts. Meanwhile, "
      + state_1_data.state_name + " is a state party to "
      + toString(state_1_data.total_conflicts) + " total '" + target_conflict_type + "' conflicts: "
      + apoc.text.join(state_1_data.conflict_names, ", ") + "."
    WHEN state_1_data.total_conflicts > state_2_data.total_conflicts THEN
      "According to RULAC, in a comparison between "
      + state_1_data.state_name + " and " + state_2_data.state_name
      + ", the state currently party to the most distinct '" + target_conflict_type + "' conflicts is "
      + state_1_data.state_name + ", being a state party to "
      + toString(state_1_data.total_conflicts) + " total '" + target_conflict_type + "' conflicts: "
      + apoc.text.join(state_1_data.conflict_names, ", ") + ". Meanwhile, "
      + state_2_data.state_name + " is a state party to "
      + toString(state_2_data.total_conflicts) + " total '" + target_conflict_type + "' conflicts: "
      + apoc.text.join(state_2_data.conflict_names, ", ") + "."
    WHEN state_2_data.total_conflicts > state_1_data.total_conflicts THEN
      "According to RULAC, in a comparison between "
      + state_1_data.state_name + " and " + state_2_data.state_name
      + ", the state currently party to the most distinct '" + target_conflict_type + "' conflicts is "
      + state_2_data.state_name + ", being a state party to "
      + toString(state_2_data.total_conflicts) + " total '" + target_conflict_type + "' conflicts: "
      + apoc.text.join(state_2_data.conflict_names, ", ") + ". Meanwhile, "
      + state_1_data.state_name + " is a state party to "
      + toString(state_1_data.total_conflicts) + " total '" + target_conflict_type + "' conflicts: "
      + apoc.text.join(state_1_data.conflict_names, ", ") + "."
    ELSE
      // same number of conflicts for both
      "According to RULAC, in a comparison between "
      + state_1_data.state_name + " and " + state_2_data.state_name
      + ", both states are equally party to "
      + toString(state_1_data.total_conflicts) + " total '" + target_conflict_type + "' conflicts. "
      + state_1_data.state_name + " is party to: "
      + apoc.text.join(state_1_data.conflict_names, ", ") + ". "
      + state_2_data.state_name + " is party to: "
      + apoc.text.join(state_2_data.conflict_names, ", ") + "."
  END,

  // Flattened conflict details for both states
  conflict_details: conflict_details

}} AS RULAC_research









Example 5a: Retreiving conflicts details from conflicts taking place in a region
Research Question: What conflicts are taking place in West Africa region?
Generated Query:

////////////////////////////////////////////////////////////////////////
// EXAMPLE 5 (Parametrized Regional Grouping via UN M49):
//
// This query retrieves all conflicts that are happening or occuring in 
//  a specified UN M49 region or subregion (e.g., West Africa 
// = code "011"). We effectively look for conflicts that are 
// "taking place" in countries belonging to that region.
//
// HIGH-LEVEL LOGIC:
//   1) We define a list of target region codes (e.g. ["011"] for West Africa).
//   2) We MATCH the corresponding GeoRegion nodes, if any.
//   3) We OPTIONAL MATCH countries that BELONG_TO that region, and 
//      any conflicts TAKING_PLACE_IN those countries.
//   4) We OPTIONAL MATCH the conflicts' classification and all actors.
//   5) For each (region, country) pair, we count how many distinct 
//      conflicts appear, and build a 'conflict_details' list of 
//      each conflict's classification, parties, etc.
//   6) Finally, we aggregate this country-level data into a breakdown 
//      for the entire region, compute the total distinct conflicts, 
//      and construct a dynamic summary.
//
// REUSE BY:
//   - Changing the array in step 0 (target_region_codes) 
//     to the desired region or subregion code(s).
//   - The query returns a single JSON-like object named RULAC_research 
//     with a summary and conflict_details array.
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// 0. Define the array of target region codes (here "011" = West Africa)
////////////////////////////////////////////////////////////////////////
WITH ["061"] AS target_region_codes

////////////////////////////////////////////////////////////////////////
// 1. MATCH the GeoRegion node(s) whose UN_M49Code is in that array
////////////////////////////////////////////////////////////////////////
MATCH (gr:GeoRegion)
WHERE gr.UN_M49Code IN target_region_codes

////////////////////////////////////////////////////////////////////////
// 2. OPTIONAL MATCH countries belonging to that region, plus 
//    conflicts in those countries
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c:Conflict)-[:IS_TAKING_PLACE_IN_COUNTRY]->(country:Country)-[:BELONGS_TO]->(gr)

////////////////////////////////////////////////////////////////////////
// 3. OPTIONAL MATCH classification and actors for each conflict
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)
OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(actor)

////////////////////////////////////////////////////////////////////////
// 4. At this point, we have rows of (region, country, conflict, classification, actor).
//    We aggregate to reduce duplicates and build per-country data.
////////////////////////////////////////////////////////////////////////
WITH 
  gr.name AS region_name,
  gr.UN_M49Code AS geo_region_UN_M49Code,
  country.name AS country_name,
  c,
  ct,
  COLLECT(DISTINCT actor) AS all_actors

////////////////////////////////////////////////////////////////////////
// 5. Build for each (region, country):
//      - total_conflicts_per_country = COUNT(DISTINCT c)
//      - conflict_details = array of conflict maps
////////////////////////////////////////////////////////////////////////
WITH 
  region_name,
  geo_region_UN_M49Code,
  country_name,
  COUNT(DISTINCT c) AS total_conflicts_per_country,
  CASE 
    WHEN COUNT(DISTINCT c) = 0 THEN 
      []
    ELSE 
      COLLECT(DISTINCT {{
        conflict_name: COALESCE(c.name, "Unknown"),
        conflict_classification: COALESCE(ct.type, "Unclassified"),
        conflict_overview: COALESCE(c.overview, "No Overview Available"),
        applicable_ihl_law: COALESCE(c.applicable_law, "Not Specified"),
        conflict_citation: COALESCE(c.citation, "No Citation Available"),
        state_parties: CASE 
          WHEN all_actors IS NULL 
               OR size([p IN all_actors WHERE "StateActor" IN labels(p)]) = 0 
            THEN "No state actors recorded" 
          ELSE apoc.text.join(
            [p IN all_actors WHERE "StateActor" IN labels(p) | p.name], 
            ", "
          ) 
        END,
        non_state_parties: CASE 
          WHEN all_actors IS NULL 
               OR size([p IN all_actors WHERE "NonStateActor" IN labels(p)]) = 0 
            THEN "No non-state actors recorded" 
          ELSE apoc.text.join(
            [p IN all_actors WHERE "NonStateActor" IN labels(p) | p.name], 
            ", "
          ) 
        END
      }})
  END AS conflict_details

////////////////////////////////////////////////////////////////////////
// 6. Also build a quick country-level list of conflict names 
//    for easier textual summary. 
////////////////////////////////////////////////////////////////////////
WITH 
  region_name,
  geo_region_UN_M49Code,
  country_name,
  total_conflicts_per_country,
  conflict_details,
  CASE 
    WHEN total_conflicts_per_country = 0 THEN ""
    ELSE apoc.text.join(
      [conflict IN conflict_details | conflict.conflict_name], 
      ", "
    )
  END AS conflict_names_per_country

////////////////////////////////////////////////////////////////////////
// 7. Collect the per-country strings like:
//      "3 conflicts in Nigeria: Conflict1, Conflict2, Conflict3"
//    Also collect ALL conflict_details in one structure so we can 
//    eventually flatten them and count distinct conflicts region-wide.
////////////////////////////////////////////////////////////////////////
WITH 
  region_name,
  geo_region_UN_M49Code,
  COLLECT(
    CASE 
      WHEN total_conflicts_per_country = 0 THEN 
        NULL
      ELSE 
        toString(total_conflicts_per_country) 
        + " conflict(s) taking place in " + country_name + ": " 
        + conflict_names_per_country
    END
  ) AS total_conflicts_by_country,
  COLLECT(conflict_details) AS all_conflicts_per_country

////////////////////////////////////////////////////////////////////////
// 8. Filter out the NULL entries. 
//    Flatten all the country conflict_details 
//    so we can count total distinct conflicts across the entire region.
////////////////////////////////////////////////////////////////////////
WITH 
  region_name,
  geo_region_UN_M49Code,
  [t IN total_conflicts_by_country WHERE t IS NOT NULL] AS filtered_conflicts_by_country,
  apoc.coll.flatten(all_conflicts_per_country) AS conflict_details

////////////////////////////////////////////////////////////////////////
// 9. Compute total distinct conflicts region-wide
////////////////////////////////////////////////////////////////////////
WITH 
  region_name,
  geo_region_UN_M49Code,
  filtered_conflicts_by_country,
  conflict_details,
  CASE 
    WHEN conflict_details = [] 
      THEN 0 
    ELSE 
      size(
        apoc.coll.toSet(
          [d IN conflict_details | d.conflict_name]
        )
      )
  END AS total_distinct_conflicts

////////////////////////////////////////////////////////////////////////
// 10. Build the summary text and return the final object
////////////////////////////////////////////////////////////////////////
RETURN {{
  summary: CASE 
    WHEN total_distinct_conflicts = 0 THEN
      "According to RULAC, there are currently no recorded armed conflicts "
      + " taking place in " + region_name 
      + " (UN M49 code: " + geo_region_UN_M49Code + ")."
    ELSE
      "According to RULAC, there are curently " + toString(total_distinct_conflicts) + " distinct armed conflict(s) taking place in " + region_name 
      + " (UN M49 code: " + geo_region_UN_M49Code + "). "
      + "Breakdown by country: " 
      + apoc.text.join(filtered_conflicts_by_country, "; ")
  END,
  conflict_details: conflict_details
}} AS RULAC_research







Example 5a2: Retreiving conflicts details from conflicts taking place in a region that needs to be manually defined by grouping countries
Research Question: Which ongoing conflicts are taking place in the Sahel region?
Generated Query:  // 0. Define the array of target country codes (e.g. ["686", "478", "466", "854", "562", "148", "729"] = Sahel Region)
  
  WITH ["686", "478", "466", "854", "562", "148", "729"] AS target_country_codes

  // 1. MATCH conflicts taking place in these countries
  OPTIONAL MATCH (c:Conflict)-[:IS_TAKING_PLACE_IN_COUNTRY]->(country:Country)
  WHERE country.UN_M49Code IN target_country_codes

  // 2. OPTIONAL MATCH classification and actors for each conflict
  OPTIONAL MATCH (c)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)
  OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(actor)

  // 3. At this point, we have rows of (country, conflict, classification, actor).
  //    We aggregate to reduce duplicates and build per-country data.
  WITH
    country.name AS country_name,
    c,
    ct,
    COLLECT(DISTINCT actor) AS all_actors

  // 4. Build for each (country):
  //      - total_conflicts_per_country = COUNT(DISTINCT c)
  //      - conflict_details = array of conflict maps
  WITH
    country_name,
    COUNT(DISTINCT c) AS total_conflicts_per_country,
    CASE
      WHEN COUNT(DISTINCT c) = 0 THEN
        []
      ELSE
        COLLECT(DISTINCT {{
          conflict_name: COALESCE(c.name, "Unknown"),
          conflict_classification: COALESCE(ct.type, "Unclassified"),
          conflict_overview: COALESCE(c.overview, "No Overview Available"),
          applicable_ihl_law: COALESCE(c.applicable_law, "Not Specified"),
          conflict_citation: COALESCE(c.citation, "No Citation Available"),
          state_parties: CASE
            WHEN all_actors IS NULL
                 OR size([p IN all_actors WHERE "StateActor" IN labels(p)]) = 0
              THEN "No state actors recorded"
            ELSE apoc.text.join(
              [p IN all_actors WHERE "StateActor" IN labels(p) | p.name],
              ", "
            )
          END,
          non_state_parties: CASE
            WHEN all_actors IS NULL
                 OR size([p IN all_actors WHERE "NonStateActor" IN labels(p)]) = 0
              THEN "No non-state actors recorded"
            ELSE apoc.text.join(
              [p IN all_actors WHERE "NonStateActor" IN labels(p) | p.name],
              ", "
            )
          END
        }})
    END AS conflict_details

  // 5. Also build a quick country-level list of conflict names
  //    for easier textual summary.
  WITH
    country_name,
    total_conflicts_per_country,
    conflict_details,
    CASE
      WHEN total_conflicts_per_country = 0 THEN ""
      ELSE apoc.text.join(
        [conflict IN conflict_details | conflict.conflict_name],
        ", "
      )
    END AS conflict_names_per_country

  // 6. Collect the per-country strings like:
  //      "3 conflicts in Nigeria: Conflict1, Conflict2, Conflict3"
  //    Also collect ALL conflict_details in one structure so we can
  //    eventually flatten them and count distinct conflicts region-wide.
  WITH
    COLLECT(
      CASE
        WHEN total_conflicts_per_country = 0 THEN
          NULL
        ELSE
          toString(total_conflicts_per_country)
          + " conflict(s) taking place in " + country_name + ": "
          + conflict_names_per_country
      END
    ) AS total_conflicts_by_country,
    COLLECT(conflict_details) AS all_conflicts_per_country

  // 7. Filter out the NULL entries.
  //    Flatten all the country conflict_details
  //    so we can count total distinct conflicts across the entire region.
  WITH
    [t IN total_conflicts_by_country WHERE t IS NOT NULL] AS filtered_conflicts_by_country,
    apoc.coll.flatten(all_conflicts_per_country) AS conflict_details

  // 8. Compute total distinct conflicts region-wide
  WITH
    filtered_conflicts_by_country,
    conflict_details,
    CASE
      WHEN conflict_details = []
        THEN 0
      ELSE
        size(
          apoc.coll.toSet(
            [d IN conflict_details | d.conflict_name]
          )
        )
    END AS total_distinct_conflicts

  // 9. Build the summary text and return the final object
  RETURN {{
    summary: CASE
      WHEN total_distinct_conflicts = 0 THEN
        "According to RULAC, there are currently no recorded armed conflicts "
        + "taking place in the Sahel region, which is defined by the following countries: Senegal, Mauritania, Mali, Burkina Faso, Niger, Chad, and Sudan."
      ELSE
        "According to RULAC, there are currently "
        + toString(total_distinct_conflicts) + " distinct armed conflict(s) taking place in the Sahel region, which is defined by the following countries: Senegal, Mauritania, Mali, Burkina Faso, Niger, Chad, and Sudan. "
        + "Breakdown by country: "
        + apoc.text.join(filtered_conflicts_by_country, "; ")
    END,
    conflict_details: conflict_details
  }} AS RULAC_research



Example 5b : Retreiving conflict counts for state actors in a region
Research Question: What conflicts involve state actors that are from the Latin America area?
Generated Query:
////////////////////////////////////////////////////////////////////////
// EXAMPLE 5b (Adapted for StateActors in a Region):
//
// This query retrieves all conflicts "involving state actors" that 
// are located in a specific UN M49 region or subregion (e.g., Latin 
// America = code "419"). 
//
// HIGH-LEVEL LOGIC:
//  1) We define the target region code(s) in an array.
//  2) We MATCH the GeoRegion node(s).
//  3) We OPTIONAL MATCH any StateActor node belonging to that region.
//  4) For each StateActor, we OPTIONAL MATCH any Conflict they are 
//     party to, plus classification and parties.
//  5) We aggregate conflicts per state actor: total_conflicts_per_state_actor
//     and a conflict_details list.
//  6) We compute a region-wide distinct conflict count and build a 
//     dynamic summary string, then return a JSON-like object.
//
// REUSE BY:
//  - Changing the array in step 0, e.g. ["419"] for Latin America.
//  - The final output is in the 'RULAC_research' structure.
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// 0. Define the array of target region codes (e.g. ["419"] = Latin America)
////////////////////////////////////////////////////////////////////////
WITH ["419"] AS target_region_codes

////////////////////////////////////////////////////////////////////////
// 1. MATCH any GeoRegion node(s) in that array
////////////////////////////////////////////////////////////////////////
MATCH (gr:GeoRegion)
WHERE gr.UN_M49Code IN target_region_codes

////////////////////////////////////////////////////////////////////////
// 2. OPTIONAL MATCH each StateActor that BELONGS_TO this region
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (sa:StateActor)-[:BELONGS_TO]->(gr)

////////////////////////////////////////////////////////////////////////
// 3. OPTIONAL MATCH conflicts for each state actor, plus classification 
//    and other actors
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (sa)-[:IS_PARTY_TO_CONFLICT]->(c:Conflict)
OPTIONAL MATCH (c)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)
OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(actor)

////////////////////////////////////////////////////////////////////////
// 4. Group by (region, state_actor), collecting distinct conflicts and 
//    other data
////////////////////////////////////////////////////////////////////////
WITH 
  gr.name AS region_name,
  gr.UN_M49Code AS geo_region_UN_M49Code,
  sa.name AS state_actor_name,
  COLLECT(DISTINCT actor) AS all_actors,
  c,
  ct

////////////////////////////////////////////////////////////////////////
// 5. For each state actor, count distinct conflicts and build conflict_details
////////////////////////////////////////////////////////////////////////
WITH
  region_name,
  geo_region_UN_M49Code,
  state_actor_name,
  COUNT(DISTINCT c) AS total_conflicts_per_state_actor,
  CASE 
    WHEN COUNT(DISTINCT c) = 0 THEN 
      // If no conflicts, return empty list
      []
    ELSE 
      COLLECT(DISTINCT {{
        conflict_name: COALESCE(c.name, "Unknown"),
        conflict_classification: COALESCE(ct.type, "Unclassified"),
        conflict_overview: COALESCE(c.overview, "No Overview Available"),
        applicable_ihl_law: COALESCE(c.applicable_law, "Not Specified"),
        conflict_citation: COALESCE(c.citation, "No Citation Available"),
        state_parties: CASE 
          WHEN all_actors IS NULL
               OR size([p IN all_actors WHERE "StateActor" IN labels(p)]) = 0 
            THEN "No state actors recorded" 
          ELSE apoc.text.join(
            [p IN all_actors WHERE "StateActor" IN labels(p) | p.name], 
            ", "
          )
        END,
        non_state_parties: CASE 
          WHEN all_actors IS NULL
               OR size([p IN all_actors WHERE "NonStateActor" IN labels(p)]) = 0 
            THEN "No non-state actors recorded" 
          ELSE apoc.text.join(
            [p IN all_actors WHERE "NonStateActor" IN labels(p) | p.name], 
            ", "
          )
        END
      }})
  END AS conflict_details

////////////////////////////////////////////////////////////////////////
// 6. Build a comma-separated conflict name string for summary
////////////////////////////////////////////////////////////////////////
WITH
  region_name,
  geo_region_UN_M49Code,
  state_actor_name,
  total_conflicts_per_state_actor,
  conflict_details,
  CASE 
    WHEN total_conflicts_per_state_actor = 0 THEN ""
    ELSE apoc.text.join([conflict IN conflict_details | conflict.conflict_name], ", ")
  END AS conflict_names_per_state_actor

////////////////////////////////////////////////////////////////////////
// 7. Collect each state's conflict summary into two lists:
//     - total_conflicts_by_state_actor: textual lines describing each 
//       state's # of conflicts and conflict names
//     - all_conflicts_per_state_actor: for building a region-wide 
//       distinct conflict set
////////////////////////////////////////////////////////////////////////
WITH
  region_name,
  geo_region_UN_M49Code,
  COLLECT(
    CASE 
      WHEN total_conflicts_per_state_actor = 0 THEN 
        NULL
      ELSE 
        toString(total_conflicts_per_state_actor)
        + " conflict(s) involving " + state_actor_name + ": "
        + conflict_names_per_state_actor
    END
  ) AS total_conflicts_by_state_actor,
  COLLECT(conflict_details) AS all_conflicts_per_state_actor

////////////////////////////////////////////////////////////////////////
// 8. Filter out NULL lines and flatten the conflict details
////////////////////////////////////////////////////////////////////////
WITH
  region_name,
  geo_region_UN_M49Code,
  [line IN total_conflicts_by_state_actor WHERE line IS NOT NULL] AS filtered_conflicts_by_state_actor,
  apoc.coll.flatten(all_conflicts_per_state_actor) AS conflict_details

////////////////////////////////////////////////////////////////////////
// 9. Count the total distinct conflict names across all state actors 
//    in this region
////////////////////////////////////////////////////////////////////////
WITH
  region_name,
  geo_region_UN_M49Code,
  filtered_conflicts_by_state_actor,
  conflict_details,
  CASE 
    WHEN conflict_details = [] THEN 0
    ELSE size(
      apoc.coll.toSet(
        [d IN conflict_details | d.conflict_name]
      )
    )
  END AS total_distinct_conflicts

////////////////////////////////////////////////////////////////////////
// 10. Construct summary and return final JSON-like object
////////////////////////////////////////////////////////////////////////
RETURN {{
  summary: CASE
    WHEN total_distinct_conflicts = 0 THEN
      "According to RULAC, there are currently no recorded armed conflicts "
      + "involving any state actors from " + region_name 
      + " (UN M49 code: " + geo_region_UN_M49Code + ")."
    ELSE
      "According to RULAC, there are currently "
      + toString(total_distinct_conflicts) 
      + " distinct armed conflict(s) involving state actors from " 
      + region_name + " (UN M49 code: " + geo_region_UN_M49Code + "). "
      + "Breakdown by state actor: "
      + apoc.text.join(filtered_conflicts_by_state_actor, "; ")
  END,
  conflict_details: conflict_details
}} AS RULAC_research


Example 5b.2 : Retreiving conflict counts for state actors in a region by conflict type
Research Question: Are there any military occupations involving state actors from South America?
Generated Query:
WITH "005" AS target_region_code,  
     "South America" AS target_region_name,
     "Military Occupation" AS target_conflict_type

MATCH (gr:GeoRegion)
WHERE gr.UN_M49Code = target_region_code

OPTIONAL MATCH (sa:StateActor)-[:BELONGS_TO]->(gr)

OPTIONAL MATCH (sa)-[:IS_PARTY_TO_CONFLICT]->(c:Conflict)
       -[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)
WHERE ct.type = target_conflict_type

OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(actor)

WITH 
  target_region_code,
  target_region_name,
  target_conflict_type,
  sa.name AS state_actor_name,
  COLLECT(DISTINCT actor) AS all_actors,
  COLLECT(DISTINCT c) AS conflict_list

WITH 
  target_region_code,
  target_region_name,
  target_conflict_type,
  state_actor_name,
  conflict_list,
  all_actors,
  SIZE(conflict_list) AS total_conflicts,
  [conf IN conflict_list | conf.name] AS conflict_names

WITH
  target_region_code,
  target_region_name,
  target_conflict_type,
  state_actor_name,
  total_conflicts,
  conflict_names,
  all_actors,

  [conf IN conflict_list |
    {{
      conflict_name: COALESCE(conf.name, "Unknown"),
      conflict_classification: target_conflict_type,
      conflict_overview: COALESCE(conf.overview, "No Overview Available"),
      applicable_ihl_law: COALESCE(conf.applicable_law, "Not Specified"),
      conflict_citation: COALESCE(conf.citation, "No Citation Available"),

      state_parties: CASE
        WHEN SIZE([
          p IN all_actors
          WHERE "StateActor" IN labels(p)
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
        ]) = 0
          THEN "No state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors
            WHERE "StateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
            | p.name
          ],
          ", "
        )
      END,

      non_state_parties: CASE
        WHEN SIZE([
          p IN all_actors
          WHERE "NonStateActor" IN labels(p)
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
        ]) = 0
          THEN "No non-state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors
            WHERE "NonStateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
            | p.name
          ],
          ", "
        )
      END
    }}
  ] AS conflict_details

WITH 
  target_region_code,
  target_region_name,
  target_conflict_type,
  COLLECT(
    CASE 
      WHEN total_conflicts = 0 THEN 
        NULL
      ELSE 
        toString(total_conflicts)
        + " '" + target_conflict_type + "' conflict(s) involving "
        + state_actor_name + ": "
        + apoc.text.join(conflict_names, ", ")
    END
  ) AS state_conflict_summaries,
  COLLECT(conflict_details) AS all_conflicts_per_state_actor

WITH 
  target_region_code,
  target_region_name,
  target_conflict_type,
  [s IN state_conflict_summaries WHERE s IS NOT NULL] AS filtered_state_summaries,
  apoc.coll.flatten(all_conflicts_per_state_actor) AS conflict_details

WITH 
  target_region_code,
  target_region_name,
  target_conflict_type,
  filtered_state_summaries,
  conflict_details,
  SIZE(apoc.coll.toSet([d IN conflict_details | d.conflict_name])) AS total_distinct_conflicts

RETURN {{
  summary: CASE
    WHEN total_distinct_conflicts = 0 THEN
      "According to RULAC, there are currently no recorded '" 
      + target_conflict_type + "' conflicts involving state actors from " 
      + target_region_name + " (UN M49 Code: " + target_region_code + ")."
    ELSE
      "According to RULAC, there are currently " 
      + toString(total_distinct_conflicts) 
      + " distinct '" + target_conflict_type + "' conflict(s) involving state actors from " 
      + target_region_name + " (UN M49 Code: " + target_region_code + "). "
      + "Breakdown by state actor: " + apoc.text.join(filtered_state_summaries, "; ")
  END,
  conflict_details: conflict_details
}} AS RULAC_research





Example 5c : Retreiving conflict counts for state actors in a region that needs to be manually defined by grouping countries 
Research Question: What conflicts involve state actors from the Horn of Africa? 
Generated Query:
  // 0. Define the array of target country codes (e.g. ["262", "232", "231", "706"] = Horn of Africa)

  WITH ["262", "232", "231", "706"] AS target_country_codes

  // 2. OPTIONAL MATCH conflicts for each state actor, plus classification
  //    and other actors
  OPTIONAL MATCH (sa:StateActor)-[:IS_PARTY_TO_CONFLICT]->(c:Conflict)
  WHERE sa.UN_M49Code IN target_country_codes

  OPTIONAL MATCH (c)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)
  OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(actor)

  // 3. Group by (state_actor), collecting distinct conflicts and
  //    other data
  WITH
    sa.name AS state_actor_name,
    COLLECT(DISTINCT actor) AS all_actors,
    c,
    ct

  // 4. For each state actor, count distinct conflicts and build conflict_details
  WITH
    state_actor_name,
    COUNT(DISTINCT c) AS total_conflicts_per_state_actor,
    CASE
      WHEN COUNT(DISTINCT c) = 0 THEN
        // If no conflicts, return empty list
        []
      ELSE
        COLLECT(DISTINCT {{
          conflict_name: COALESCE(c.name, "Unknown"),
          conflict_classification: COALESCE(ct.type, "Unclassified"),
          conflict_overview: COALESCE(c.overview, "No Overview Available"),
          applicable_ihl_law: COALESCE(c.applicable_law, "Not Specified"),
          conflict_citation: COALESCE(c.citation, "No Citation Available"),
          state_parties: CASE
            WHEN all_actors IS NULL
                 OR size([p IN all_actors WHERE "StateActor" IN labels(p)]) = 0
              THEN "No state actors recorded"
            ELSE apoc.text.join(
              [p IN all_actors WHERE "StateActor" IN labels(p) | p.name],
              ", "
            )
          END,
          non_state_parties: CASE
            WHEN all_actors IS NULL
                 OR size([p IN all_actors WHERE "NonStateActor" IN labels(p)]) = 0
              THEN "No non-state actors recorded"
            ELSE apoc.text.join(
              [p IN all_actors WHERE "NonStateActor" IN labels(p) | p.name],
              ", "
            )
          END
        }})
    END AS conflict_details

  // 5. Build a comma-separated conflict name string for summary
  WITH
    state_actor_name,
    total_conflicts_per_state_actor,
    conflict_details,
    CASE
      WHEN total_conflicts_per_state_actor = 0 THEN ""
      ELSE apoc.text.join([conflict IN conflict_details | conflict.conflict_name], ", ")
    END AS conflict_names_per_state_actor

  // 6. Collect each state's conflict summary into two lists:
  //     - total_conflicts_by_state_actor: textual lines describing each
  //       state's # of conflicts and conflict names
  //     - all_conflicts_per_state_actor: for building a region-wide
  //       distinct conflict set
  WITH
    COLLECT(
      CASE
        WHEN total_conflicts_per_state_actor = 0 THEN
          NULL
        ELSE
          toString(total_conflicts_per_state_actor)
          + " conflict(s) involving " + state_actor_name + ": "
          + conflict_names_per_state_actor
      END
    ) AS total_conflicts_by_state_actor,
    COLLECT(conflict_details) AS all_conflicts_per_state_actor

  // 7. Filter out NULL lines and flatten the conflict details
  WITH
    [line IN total_conflicts_by_state_actor WHERE line IS NOT NULL] AS filtered_conflicts_by_state_actor,
    apoc.coll.flatten(all_conflicts_per_state_actor) AS conflict_details

  // 8. Count the total distinct conflict names across all state actors
  //    in this region
  WITH
    filtered_conflicts_by_state_actor,
    conflict_details,
    CASE
      WHEN conflict_details = [] THEN 0
      ELSE size(
        apoc.coll.toSet(
          [d IN conflict_details | d.conflict_name]
        )
      )
    END AS total_distinct_conflicts

  // 9. Construct summary and return final JSON-like object
  RETURN {{
    summary: CASE
      WHEN total_distinct_conflicts = 0 THEN
        "According to RULAC, there are currently no recorded armed conflicts "
        + "involving any state actors from the Horn of Africa region, which is defined by the following countries: Djibouti, Eritrea, Ethiopia, and Somalia."
      ELSE
        "According to RULAC, there are currently "
        + toString(total_distinct_conflicts)
        + " distinct armed conflict(s) involving state actors from the Horn of Africa region, which is defined by the following countries: Djibouti, Eritrea, Ethiopia, and Somalia. "
        + "Breakdown by state actor: "
        + apoc.text.join(filtered_conflicts_by_state_actor, "; ")
    END,
    conflict_details: conflict_details
  }} AS RULAC_research



Example 7 : Retreiving conflict counts for state actors in a political or organizational group
Research Question: What conflicts involve European Union members?
Generated Query:
////////////////////////////////////////////////////////////////////////
// EXAMPLE: Querying Conflicts for an Existing Organization & Its Members
//
// This query finds all conflicts involving an Organization node
// (e.g. "European Union") and its member states (using :IS_MEMBER).
// It then returns:
//   1) The total number of distinct conflicts 
//   2) A list of all distinct conflict names
//   3) A breakdown by each member state
//   4) The actual names of all member states in parentheses
//
// HOW TO REUSE:
//   1) Change "European Union" below to the organization name
//      (like "NATO", "African Union", "G7", "BRICS", "ASEAN", etc.)
//   2) Ensure your DB has (:StateActor)-[:IS_MEMBER]->(:Organization).
//   3) Run the query to produce a JSON-like object named `RULAC_research`.
//
// NOTE: This query REALLY ALWAYS returns exactly one row,
//       even if org is missing or has no data.
////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////
// 0. Identify the organization name (example: "European Union")
////////////////////////////////////////////////////////////////////////

WITH "European Union" AS target_group_name


////////////////////////////////////////////////////////////////////////
// 1. OPTIONAL MATCH the Organization by name.
//    - If none found, org = null, but we keep a single row.
////////////////////////////////////////////////////////////////////////

OPTIONAL MATCH (org:Organization {{name: target_group_name}})


////////////////////////////////////////////////////////////////////////
// 2. OPTIONAL MATCH all StateActor nodes that are members of this org.
//    - If org = null or no :IS_MEMBER relationships, we still keep 1 row
//      with 'members' = [].
////////////////////////////////////////////////////////////////////////

OPTIONAL MATCH (sa:StateActor)-[:IS_MEMBER]->(org)


////////////////////////////////////////////////////////////////////////
// 3. Collect all member states in a single list
////////////////////////////////////////////////////////////////////////

WITH 
  org, 
  target_group_name,
  COLLECT(DISTINCT sa) AS members


////////////////////////////////////////////////////////////////////////
// 4. Subquery: gather conflicts & details for each member. 
//    If members = [], we replace it with [null], so subquery 
//    yields exactly 1 row (with state=null). That preserves 
//    our main pipeline row.
////////////////////////////////////////////////////////////////////////

CALL {{
  //////////////////////////////////////////////////////////////////////////
  // A) Ensure at least one row even if members is empty.
  //////////////////////////////////////////////////////////////////////////

  WITH members
  WITH CASE WHEN size(members)=0 THEN [null] ELSE members END AS safe_members
  UNWIND safe_members AS state

  //////////////////////////////////////////////////////////////////////////
  // B) OPTIONAL MATCH conflicts for each state
  //////////////////////////////////////////////////////////////////////////

  OPTIONAL MATCH (state)-[:IS_PARTY_TO_CONFLICT]->(c:Conflict)
  OPTIONAL MATCH (c)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)
  OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(actor)

  //////////////////////////////////////////////////////////////////////////
  // C) Aggregate data for that single state
  //////////////////////////////////////////////////////////////////////////

  WITH 
    state,
    COLLECT(DISTINCT c) AS conflict_list,
    COLLECT(DISTINCT actor) AS all_actors,
    COLLECT(DISTINCT {{conflict: c, type: ct.type}}) AS conflict_type_pairs

  //////////////////////////////////////////////////////////////////////////
  // D) Summarize how many conflicts, their names, etc. 
  //    (We must pass conflict_list forward if we use it again.)
  //////////////////////////////////////////////////////////////////////////

  WITH
    state,
    conflict_list,
    SIZE(conflict_list) AS total_conflicts,
    [conf IN conflict_list | conf.name] AS conflict_names,
    all_actors,
    conflict_type_pairs

  //////////////////////////////////////////////////////////////////////////
  // E) Build detailed info for each conflict 
  //    - If state=null, conflict_list is empty => yields no conflicts
  //////////////////////////////////////////////////////////////////////////

  WITH
    state,
    conflict_list,
    total_conflicts,
    conflict_names,
    all_actors,
    conflict_type_pairs,
    [conf IN conflict_list |
      {{
        conflict_name: COALESCE(conf.name, "Unknown"),
        conflict_classification: COALESCE(
          [pair IN conflict_type_pairs WHERE pair.conflict = conf | pair.type][0],
          "Unclassified"
        ),
        conflict_overview: COALESCE(conf.overview, "No Overview Available"),
        applicable_ihl_law: COALESCE(conf.applicable_law, "Not Specified"),
        conflict_citation: COALESCE(conf.citation, "No Citation Available"),

        state_parties: CASE
          WHEN SIZE([
            p IN all_actors
            WHERE "StateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
          ]) = 0
            THEN "No state actors recorded"
          ELSE apoc.text.join(
            [
              p IN all_actors
              WHERE "StateActor" IN labels(p)
                AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
              | p.name
            ],
            ", "
          )
        END,

        non_state_parties: CASE
          WHEN SIZE([
            p IN all_actors
            WHERE "NonStateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
          ]) = 0
            THEN "No non-state actors recorded"
          ELSE apoc.text.join(
            [
              p IN all_actors
              WHERE "NonStateActor" IN labels(p)
                AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
              | p.name
            ],
            ", "
          )
        END
      }}
    ] AS conflict_details

  //////////////////////////////////////////////////////////////////////////
  // F) Return a single map for this state (or null if state=null)
  //////////////////////////////////////////////////////////////////////////

  RETURN {{
    state_name: CASE WHEN state IS NULL THEN "NoMembersFound" ELSE COALESCE(state.name, "Unknown") END,
    state_UN_M49Code: CASE WHEN state IS NULL THEN "N/A" ELSE COALESCE(state.UN_M49Code, "N/A") END,
    total_conflicts: total_conflicts,
    conflict_names: conflict_names,
    conflict_details: conflict_details
  }} AS single_state_data
}}


////////////////////////////////////////////////////////////////////////
// G) After the subquery, we have 1 row with:
//    - members: the list of states
//    - states_conflicts: an array of single_state_data
//      (and that array has exactly 1 item if members was empty, 
//       indicating 'NoMembersFound'.)
////////////////////////////////////////////////////////////////////////

WITH 
  org,
  target_group_name,
  members,
  COLLECT(single_state_data) AS states_conflicts


////////////////////////////////////////////////////////////////////////
// 5. Flatten all conflict details across the entire org. Then collect 
//    distinct conflict names and distinct state names for the summary.
////////////////////////////////////////////////////////////////////////

WITH
  org,
  target_group_name,
  members,
  states_conflicts,
  apoc.coll.flatten([s IN states_conflicts | s.conflict_details]) AS conflict_details

WITH
  org,
  target_group_name,
  members,
  states_conflicts,
  conflict_details,
  apoc.coll.toSet([c IN conflict_details | c.conflict_name]) AS distinct_conflict_names,
  apoc.coll.toSet([s IN states_conflicts | s.state_name]) AS distinct_state_names


////////////////////////////////////////////////////////////////////////
// 6. Compute how many members, how many distinct conflicts, etc.
////////////////////////////////////////////////////////////////////////

WITH
  org,
  target_group_name,
  members,
  states_conflicts,
  conflict_details,
  distinct_conflict_names,
  distinct_state_names,
  SIZE(members) AS total_members,
  SIZE(distinct_conflict_names) AS total_distinct_conflicts


////////////////////////////////////////////////////////////////////////
// 7. Build a per-state breakdown if they have any conflicts
////////////////////////////////////////////////////////////////////////

WITH
  org,
  target_group_name,
  total_members,
  conflict_details,
  distinct_conflict_names,
  distinct_state_names,
  states_conflicts,
  total_distinct_conflicts,

  [sc IN states_conflicts WHERE sc.total_conflicts > 0 |
    toString(sc.total_conflicts)
    + " conflict(s) involving "
    + sc.state_name
    + ": "
    + apoc.text.join(sc.conflict_names, ", ")
  ] AS breakdown_list


////////////////////////////////////////////////////////////////////////
// 8. Construct final summary logic. Now we definitely have 1 row:
//    - If org is null => no org found
//    - If total_members=0 => org found but no members
//    - If total_distinct_conflicts=0 => members exist but no conflicts
//    - Otherwise => normal listing
////////////////////////////////////////////////////////////////////////

RETURN {{
  summary: CASE
    WHEN org IS NULL THEN
      "No organization named '" + target_group_name + "' was found in the database."

    WHEN total_members = 0 THEN
      "The organization '" + target_group_name + "' was found, but currently has no recorded StateActor members in the database."

    WHEN total_distinct_conflicts = 0 THEN
      "According to RULAC, there are currently no recorded armed conflicts involving any of the "
      + toString(total_members) + " members of '" + target_group_name + "': "
      + apoc.text.join(distinct_state_names, ", ") + "."

    ELSE
      "According to RULAC, '" + target_group_name
      + "' (defined as " + toString(total_members) + " members total, including: "
      + apoc.text.join(distinct_state_names, ", ") + ") contains state actors who are currently party to a total of "
      + toString(total_distinct_conflicts) + " distinct armed conflict(s). "
      + "They include: " + apoc.text.join(distinct_conflict_names, ", ") + ". "
      + "Breakdown by member: " + apoc.text.join(breakdown_list, "; ")
  END,

  conflict_details: conflict_details

}} AS RULAC_research



Example 8 : Comparing Conflicts Between Two Geographic Regions
Research Question: Are there more conflicts involving North or South America regions? 
Generated Query:
////////////////////////////////////////////////////////////////
// REFIND EXAMPLE: Comparing Two Regions
//                 with a Narrative-Style Summary
////////////////////////////////////////////////////////////////

// Define the target region codes

WITH ["005", "021"] AS target_region_codes

CALL {{
  WITH target_region_codes

  UNWIND target_region_codes AS region_code

  // Match the GeoRegion node for the current region code

  OPTIONAL MATCH (region:GeoRegion {{UN_M49Code: region_code}})

  // Match StateActor nodes that belong to the current region

  OPTIONAL MATCH (region)<-[:BELONGS_TO]-(sa:StateActor)

  // Match Conflict nodes that the StateActors are party to

  OPTIONAL MATCH (sa)-[:IS_PARTY_TO_CONFLICT]->(c:Conflict)

  // Match ConflictType nodes that classify the conflicts

  OPTIONAL MATCH (c)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)

  // Match all actors that are party to the conflicts

  OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(actor)

  WITH
    region_code,
    region,
    COLLECT(DISTINCT sa) AS region_states,
    COLLECT(DISTINCT c) AS conflict_list,
    COLLECT(DISTINCT actor) AS all_actors,
    COLLECT(DISTINCT {{conflict: c, type: ct.type}}) AS conflict_type_pairs

  // Call a subquery to process each state actor and their conflicts

  CALL {{
    WITH region_states

    UNWIND region_states AS single_state

    OPTIONAL MATCH (single_state)-[:IS_PARTY_TO_CONFLICT]->(indiv_conf:Conflict)

    WITH single_state, COLLECT(DISTINCT indiv_conf) AS indiv_conf_list

    RETURN {{
      actor_name: COALESCE(single_state.name, "UnknownActor"),
      total_conflicts: SIZE(indiv_conf_list),
      conflict_names: [ic IN indiv_conf_list | ic.name]
    }} AS single_actor_data
  }}

  WITH
    region,
    region_code,
    region_states,
    COLLECT(single_actor_data) AS actor_breakdown,
    conflict_list,
    conflict_type_pairs,
    all_actors,
    SIZE(apoc.coll.toSet([c IN conflict_list | c.name])) AS total_distinct_conflicts,
    apoc.coll.toSet([c IN conflict_list | c.name]) AS unique_conflict_names

  // Return the summary for the current region

  RETURN {{
    region_name: COALESCE(region.name, "Region with UN M49 Code " + region_code + " not found"),
    geo_region_UN_M49Code: region_code,
    number_of_state_actors_involved: SIZE([ab IN actor_breakdown WHERE ab.total_conflicts > 0]),
    total_distinct_conflicts: total_distinct_conflicts,
    conflicts_per_region: [conf IN conflict_list | {{
      conflict_name: COALESCE(conf.name, "Unknown"),
      conflict_classification: COALESCE(
        [pair IN conflict_type_pairs WHERE pair.conflict = conf | pair.type][0],
        "Unclassified"
      ),
      conflict_overview: COALESCE(conf.overview, "No Overview Available"),
      applicable_ihl_law: COALESCE(conf.applicable_law, "Not Specified"),
      conflict_citation: COALESCE(conf.citation, "No Citation Available"),
      state_parties: CASE
        WHEN SIZE([
          x IN all_actors
          WHERE "StateActor" IN labels(x)
            AND (x)-[:IS_PARTY_TO_CONFLICT]->(conf)
        ]) = 0
          THEN "No state actors recorded"
        ELSE apoc.text.join(
          [
            x IN all_actors
            WHERE "StateActor" IN labels(x)
              AND (x)-[:IS_PARTY_TO_CONFLICT]->(conf)
            | x.name
          ],
          ", "
        )
      END,
      non_state_parties: CASE
        WHEN SIZE([
          x IN all_actors
          WHERE "NonStateActor" IN labels(x)
            AND (x)-[:IS_PARTY_TO_CONFLICT]->(conf)
        ]) = 0
          THEN "No non-state actors recorded"
        ELSE apoc.text.join(
          [
            x IN all_actors
            WHERE "NonStateActor" IN labels(x)
              AND (x)-[:IS_PARTY_TO_CONFLICT]->(conf)
            | x.name
          ],
          ", "
        )
      END
    }}],
    total_region_states: SIZE(region_states),
    region_state_names: [s IN region_states | s.name],
    actor_breakdown: actor_breakdown
  }} AS single_region_summary
}}

// Collect all region summaries

WITH COLLECT(single_region_summary) AS region_summaries

// Determine which regions were found

WITH
  region_summaries,
  CASE WHEN SIZE(region_summaries) > 0 AND NOT region_summaries[0].region_name STARTS WITH "Region with UN M49 Code" THEN region_summaries[0] ELSE NULL END AS regionA,
  CASE WHEN SIZE(region_summaries) > 1 AND NOT region_summaries[1].region_name STARTS WITH "Region with UN M49 Code" THEN region_summaries[1] ELSE NULL END AS regionB

// Flatten the conflict details for all regions

WITH
  regionA, regionB, region_summaries,
  apoc.coll.flatten([s IN region_summaries | s.conflicts_per_region]) AS all_conflict_details

// Return the final summary and conflict details

RETURN {{
  summary: toString(
    CASE
      WHEN regionA IS NULL AND regionB IS NULL THEN "There are no matching GeoRegion nodes for the requested query."
      WHEN regionA IS NULL THEN
        "One region was not found. Only " + regionB.region_name + " matched. " +
        regionB.region_name + " contains " + toString(regionB.number_of_state_actors_involved) + " state actor(s) involved in " + toString(regionB.total_distinct_conflicts) + " total distinct conflict(s). " +
        "Breakdown by region: " +
        regionB.region_name + " is defined by UN M49 code " + regionB.geo_region_UN_M49Code + " and therefore currently includes " + toString(regionB.total_region_states) + " states total: " + apoc.text.join(regionB.region_state_names, ", ") + ". " +
        "Among these, " + toString(regionB.number_of_state_actors_involved) + " state actor(s) are currently involved as a state party to conflict(s): " +
        apoc.text.join([ab IN regionB.actor_breakdown WHERE ab.total_conflicts > 0 | ab.actor_name + " is state party to " + toString(ab.total_conflicts) + " conflict(s): " + apoc.text.join(ab.conflict_names, ", ")], " ")
      WHEN regionB IS NULL THEN
        "One region was not found. Only " + regionA.region_name + " matched. " +
        regionA.region_name + " contains " + toString(regionA.number_of_state_actors_involved) + " state actor(s) involved in " + toString(regionA.total_distinct_conflicts) + " total distinct conflict(s). " +
        "Breakdown by region: " +
        regionA.region_name + " is defined by UN M49 code " + regionA.geo_region_UN_M49Code + " and therefore currently includes " + toString(regionA.total_region_states) + " states total: " + apoc.text.join(regionA.region_state_names, ", ") + ". " +
        "Among these, " + toString(regionA.number_of_state_actors_involved) + " state actor(s) are currently involved as a state party to conflict(s): " +
        apoc.text.join([ab IN regionA.actor_breakdown WHERE ab.total_conflicts > 0 | ab.actor_name + " is state party to " + toString(ab.total_conflicts) + " conflict(s): " + apoc.text.join(ab.conflict_names, ", ")], " ")
      ELSE
        "According to RULAC, in a comparison between " + regionA.region_name + " and " + regionB.region_name + ", the region with state actor involvement in the most distinct conflicts is " +
        CASE WHEN regionA.total_distinct_conflicts >= regionB.total_distinct_conflicts THEN regionA.region_name ELSE regionB.region_name END + " (UN M49 code: " +
        CASE WHEN regionA.total_distinct_conflicts >= regionB.total_distinct_conflicts THEN regionA.geo_region_UN_M49Code ELSE regionB.geo_region_UN_M49Code END + "), " +
        "with " + toString(CASE WHEN regionA.total_distinct_conflicts >= regionB.total_distinct_conflicts THEN regionA.number_of_state_actors_involved ELSE regionB.number_of_state_actors_involved END) +
        " state actor(s) involved across " + toString(CASE WHEN regionA.total_distinct_conflicts >= regionB.total_distinct_conflicts THEN regionA.total_distinct_conflicts ELSE regionB.total_distinct_conflicts END) +
        " total distinct conflict(s). " +
        "By comparison, " + CASE WHEN regionA.total_distinct_conflicts < regionB.total_distinct_conflicts THEN regionA.region_name ELSE regionB.region_name END + " contains " +
        toString(CASE WHEN regionA.total_distinct_conflicts < regionB.total_distinct_conflicts THEN regionA.number_of_state_actors_involved ELSE regionB.number_of_state_actors_involved END) +
        " state actor(s) involved in " + toString(CASE WHEN regionA.total_distinct_conflicts < regionB.total_distinct_conflicts THEN regionA.total_distinct_conflicts ELSE regionB.total_distinct_conflicts END) + " total distinct conflict(s). " +
        "Breakdown by region: " +
        regionA.region_name + " is defined by UN M49 code " + regionA.geo_region_UN_M49Code + " and therefore currently includes " + toString(regionA.total_region_states) + " states total: " + apoc.text.join(regionA.region_state_names, ", ") + ". " +
        "Among these, " + toString(regionA.number_of_state_actors_involved) + " state actor(s) are currently involved as a state party to conflict(s): " +
        apoc.text.join([ab IN regionA.actor_breakdown WHERE ab.total_conflicts > 0 | ab.actor_name + " is state party to " + toString(ab.total_conflicts) + " conflict(s): " + apoc.text.join(ab.conflict_names, ", ")], " ") +
        regionB.region_name + " is defined by UN M49 code " + regionB.geo_region_UN_M49Code + " and therefore currently includes " + toString(regionB.total_region_states) + " states total: " + apoc.text.join(regionB.region_state_names, ", ") + ". " +
        "Among these, " + toString(regionB.number_of_state_actors_involved) + " state actor(s) are currently involved as a state party to conflict(s): " +
        apoc.text.join([ab IN regionB.actor_breakdown WHERE ab.total_conflicts > 0 | ab.actor_name + " is state party to " + toString(ab.total_conflicts) + " conflict(s): " + apoc.text.join(ab.conflict_names, ", ")], " ")
    END
  ),
  conflict_details: all_conflict_details
}} AS RULAC_research



Example 8b : Comparing Conflicts Between Two Geographic Regions that are manually constructed by country groups 
Research Question: Which region has seen more conflicts: the Horn of Africa or the Sahel region? Are there more ongoing conflicts in Horn of Africa or the Sahel?
Generated Query:
////////////////////////////////////////////////////////////////
// Comparing Conflict Counts Between Two manually created regions composed of State Actor Groups
////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
// Example: Comparing Conflict Counts Between Two State Actor Groups
////////////////////////////////////////////////////////////////

// Define the parameters for two regional groups

WITH 
  ["262", "232", "231", "706"]  AS group1_country_codes,  // Horn of Africa
  ["686", "478", "466", "854", "562", "148", "729"] AS group2_country_codes,  // Sahel
  "Horn of Africa" AS group1_name,
  "Sahel" AS group2_name

CALL {{
  WITH group1_country_codes, group1_name

  UNWIND group1_country_codes AS country_code

  // Match StateActor nodes belonging to Group 1

  OPTIONAL MATCH (sa:StateActor)
  WHERE sa.UN_M49Code = country_code

  // Match conflicts involving these state actors

  OPTIONAL MATCH (sa)-[:IS_PARTY_TO_CONFLICT]->(c:Conflict)

  // Match conflict types for classification

  OPTIONAL MATCH (c)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)

  // Match all actors involved in these conflicts

  OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(actor)

  WITH 
    group1_name AS region_name,
    COLLECT(DISTINCT sa) AS region_states,
    COLLECT(DISTINCT c) AS conflict_list,
    COLLECT(DISTINCT actor) AS all_actors,
    COLLECT(DISTINCT {{ conflict: c, type: ct.type }}) AS conflict_type_pairs

  RETURN {{
    region_name: region_name,
    total_region_states: SIZE(region_states),
    region_state_names: [s IN region_states | s.name],
    number_of_state_actors_involved: SIZE([s IN region_states WHERE EXISTS {{
      MATCH (s)-[:IS_PARTY_TO_CONFLICT]->(:Conflict)
    }}]),
    total_distinct_conflicts: SIZE(apoc.coll.toSet([c IN conflict_list | c.name])),
    actor_breakdown: [s IN region_states WHERE EXISTS {{
      MATCH (s)-[:IS_PARTY_TO_CONFLICT]->(:Conflict)
    }} | {{
      actor_name: COALESCE(s.name, "UnknownActor"),
      total_conflicts: SIZE([c IN conflict_list WHERE (s)-[:IS_PARTY_TO_CONFLICT]->(c)]),
      conflict_names: [c IN conflict_list WHERE (s)-[:IS_PARTY_TO_CONFLICT]->(c) | c.name]
    }}],
    conflict_details: [conf IN conflict_list | {{
      conflict_name: COALESCE(conf.name, "Unknown"),
      conflict_classification: COALESCE(
        [pair IN conflict_type_pairs WHERE pair.conflict = conf | pair.type][0],
        "Unclassified"
      ),
      conflict_overview: COALESCE(conf.overview, "No Overview Available"),
      applicable_ihl_law: COALESCE(conf.applicable_law, "Not Specified"),
      conflict_citation: COALESCE(conf.citation, "No Citation Available"),
      state_parties: CASE
        WHEN SIZE([p IN all_actors WHERE "StateActor" IN labels(p) AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)]) = 0 
        THEN "No state actors recorded"
        ELSE apoc.text.join(
          [p IN all_actors WHERE "StateActor" IN labels(p) AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf) | p.name], 
          ", "
        )
      END,
      non_state_parties: CASE
        WHEN SIZE([p IN all_actors WHERE "NonStateActor" IN labels(p) AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)]) = 0 
        THEN "No non-state actors recorded"
        ELSE apoc.text.join(
          [p IN all_actors WHERE "NonStateActor" IN labels(p) AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf) | p.name], 
          ", "
        )
      END
    }}]
  }} AS group1_summary
}}

CALL {{
  WITH group2_country_codes, group2_name

  UNWIND group2_country_codes AS country_code

  // Match StateActor nodes belonging to Group 2

  OPTIONAL MATCH (sa:StateActor)
  WHERE sa.UN_M49Code = country_code

  // Match conflicts involving these state actors

  OPTIONAL MATCH (sa)-[:IS_PARTY_TO_CONFLICT]->(c:Conflict)

  // Match conflict types for classification

  OPTIONAL MATCH (c)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)

  // Match all actors involved in these conflicts

  OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(actor)

  WITH 
    group2_name AS region_name,
    COLLECT(DISTINCT sa) AS region_states,
    COLLECT(DISTINCT c) AS conflict_list,
    COLLECT(DISTINCT actor) AS all_actors,
    COLLECT(DISTINCT {{ conflict: c, type: ct.type }}) AS conflict_type_pairs

  RETURN {{
    region_name: region_name,
    total_region_states: SIZE(region_states),
    region_state_names: [s IN region_states | s.name],
    number_of_state_actors_involved: SIZE([s IN region_states WHERE EXISTS {{
      MATCH (s)-[:IS_PARTY_TO_CONFLICT]->(:Conflict)
    }}]),
    total_distinct_conflicts: SIZE(apoc.coll.toSet([c IN conflict_list | c.name])),
    actor_breakdown: [s IN region_states WHERE EXISTS {{
      MATCH (s)-[:IS_PARTY_TO_CONFLICT]->(:Conflict)
    }} | {{
      actor_name: COALESCE(s.name, "UnknownActor"),
      total_conflicts: SIZE([c IN conflict_list WHERE (s)-[:IS_PARTY_TO_CONFLICT]->(c)]),
      conflict_names: [c IN conflict_list WHERE (s)-[:IS_PARTY_TO_CONFLICT]->(c) | c.name]
    }}],
    conflict_details: [conf IN conflict_list | {{
      conflict_name: COALESCE(conf.name, "Unknown"),
      conflict_classification: COALESCE(
        [pair IN conflict_type_pairs WHERE pair.conflict = conf | pair.type][0],
        "Unclassified"
      ),
      conflict_overview: COALESCE(conf.overview, "No Overview Available"),
      applicable_ihl_law: COALESCE(conf.applicable_law, "Not Specified"),
      conflict_citation: COALESCE(conf.citation, "No Citation Available"),
      state_parties: CASE
        WHEN SIZE([p IN all_actors WHERE "StateActor" IN labels(p) AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)]) = 0 
        THEN "No state actors recorded"
        ELSE apoc.text.join(
          [p IN all_actors WHERE "StateActor" IN labels(p) AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf) | p.name], 
          ", "
        )
      END,
      non_state_parties: CASE
        WHEN SIZE([p IN all_actors WHERE "NonStateActor" IN labels(p) AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)]) = 0 
        THEN "No non-state actors recorded"
        ELSE apoc.text.join(
          [p IN all_actors WHERE "NonStateActor" IN labels(p) AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf) | p.name], 
          ", "
        )
      END
    }}]
  }} AS group2_summary
}}
// Aggregate results and determine the comparison logic

WITH 
  group1_summary,
  group2_summary,
  CASE 
    WHEN group1_summary.total_distinct_conflicts > group2_summary.total_distinct_conflicts THEN group1_summary
    WHEN group2_summary.total_distinct_conflicts > group1_summary.total_distinct_conflicts THEN group2_summary
    ELSE NULL // If they have the same number of conflicts
  END AS most_conflicted_region,
  apoc.coll.flatten([
    group1_summary.conflict_details, 
    group2_summary.conflict_details
  ]) AS all_conflict_details

RETURN {{
  summary: 
    CASE
      WHEN most_conflicted_region IS NOT NULL THEN 
        "According to RULAC, in a comparison between " + group1_summary.region_name + " and " + group2_summary.region_name + 
        ", the region containing the most state actors currently engaged in conflicts is " 
        + most_conflicted_region.region_name + ", with state actor involvement across " 
        + toString(most_conflicted_region.total_distinct_conflicts) + " distinct conflicts. "
      ELSE 
        "According to RULAC, in a comparison between " + group1_summary.region_name + " and " + group2_summary.region_name + 
        ", both regions are equally engaged in conflicts, each with " + toString(group1_summary.total_distinct_conflicts) + " distinct conflicts. "
    END
    + "Breakdown by region: " + group1_summary.region_name + " is defined as including " + apoc.text.join(group1_summary.region_state_names, ", ") + ". "
    + "Among these, " + toString(SIZE(group1_summary.actor_breakdown)) + " state actor(s) are currently involved as a state party to conflict(s): "
    + apoc.text.join([ab IN group1_summary.actor_breakdown | ab.actor_name + " is state party to " + toString(ab.total_conflicts) + " conflict(s): " + apoc.text.join(ab.conflict_names, ", ")], ". ") + ". "
    + group2_summary.region_name + " is defined as including " + apoc.text.join(group2_summary.region_state_names, ", ") + ". "
    + "Among these, " + toString(SIZE(group2_summary.actor_breakdown)) + " state actor(s) are currently involved as a state party to conflict(s): "
    + apoc.text.join([ab IN group2_summary.actor_breakdown | ab.actor_name + " is state party to " + toString(ab.total_conflicts) + " conflict(s): " + apoc.text.join(ab.conflict_names, ", ")], ". ") + ".",

  conflict_details: all_conflict_details
}} AS RULAC_research





## Example 9 (Ranking most global country conflict involvement)
Research Question: "Which countries are party to the most conflicts in the world?"
Generated Query:
////////////////////////////////////////////////////////////////////////
// EXAMPLE: Identifying Countries Party to the Most Conflicts
//
// This template retrieves the top 10 countries that are party to the
// most conflicts, along with detailed information about each conflict.
//
// To reuse this template, simply adjust the top WITH variables if needed.
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// 1. MATCH the StateActor nodes and their related conflicts
////////////////////////////////////////////////////////////////////////

MATCH (sa:StateActor)-[:IS_PARTY_TO_CONFLICT]->(c:Conflict)

////////////////////////////////////////////////////////////////////////
// 2. OPTIONAL MATCH the classification of these conflicts
////////////////////////////////////////////////////////////////////////

OPTIONAL MATCH (c)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)

////////////////////////////////////////////////////////////////////////
// 3. OPTIONAL MATCH all other parties to these conflicts
////////////////////////////////////////////////////////////////////////

OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(actor)

////////////////////////////////////////////////////////////////////////
// 4. Aggregate the conflicts and actors
////////////////////////////////////////////////////////////////////////

WITH
  sa.name AS state_actor,
  c,
  ct,
  COLLECT(DISTINCT {{
    name: actor.name,
    labels: labels(actor)
  }}) AS conflict_parties

////////////////////////////////////////////////////////////////////////
// 5. Count the total number of conflicts for each state actor
////////////////////////////////////////////////////////////////////////

WITH
  state_actor,
  COUNT(DISTINCT c) AS total_conflicts,
  COLLECT({{
    conflict_name: c.name,
    conflict_classification: ct.type,
    conflict_overview: c.overview,
    applicable_ihl_law: c.applicable_law,
    conflict_citation: c.citation,
    state_parties: CASE
      WHEN SIZE([p IN conflict_parties WHERE "StateActor" IN p.labels]) = 0
        THEN "No state actors recorded"
      ELSE apoc.text.join(
        [p IN conflict_parties WHERE "StateActor" IN p.labels | p.name],
        ", "
      )
    END,
    non_state_parties: CASE
      WHEN SIZE([p IN conflict_parties WHERE "NonStateActor" IN p.labels]) = 0
        THEN "No non-state actors recorded"
      ELSE apoc.text.join(
        [p IN conflict_parties WHERE "NonStateActor" IN p.labels | p.name],
        ", "
      )
    END
  }}) AS conflict_details
ORDER BY total_conflicts DESC
LIMIT 10

////////////////////////////////////////////////////////////////////////
// 6. Collect the data for the top N countries
////////////////////////////////////////////////////////////////////////

WITH
  COLLECT({{
    state_actor: state_actor,
    total_conflicts: total_conflicts,
    conflict_details: conflict_details
  }}) AS state_actor_data,
  apoc.coll.flatten(COLLECT(conflict_details)) AS conflict_details

////////////////////////////////////////////////////////////////////////
// 7. Build the summary text
////////////////////////////////////////////////////////////////////////

WITH
  state_actor_data,
  conflict_details,
  [entry IN state_actor_data |
    entry.state_actor + " is an official state actor engaged in " + toString(entry.total_conflicts) + " conflicts (" +
    apoc.text.join([conflict IN entry.conflict_details | conflict.conflict_name], ", ") + ")"
  ] AS summary_list

////////////////////////////////////////////////////////////////////////
// 8. Return the final structured object
////////////////////////////////////////////////////////////////////////

RETURN {{
  summary: "According to RULAC, the top 10 countries currently party to the most conflicts are, in order of involvement: " +
           apoc.text.join(summary_list, "; ") + ".",
  state_actor_data: state_actor_data,
  conflict_details: conflict_details
}} AS RULAC_research




## Example 10 (Ranking most  conflict involvement by organization member)
Research Question: "Which European Union countries have been party to the fewest conflicts?"
Generated Query:
////////////////////////////////////////////////////////////////////////
// EXAMPLE: Identifying EU Countries Party to the Fewest Conflicts
//
// This template retrieves the EU countries that are party to the
// fewest conflicts, along with detailed information about each conflict.
//
// To reuse this template, simply adjust the top WITH variables if needed.
////////////////////////////////////////////////////////////////////////

WITH "European Union" AS target_group_name

OPTIONAL MATCH (org:Organization {{name: target_group_name}})
OPTIONAL MATCH (sa:StateActor)-[:IS_MEMBER]->(org)

WITH
  org,
  target_group_name,
  COLLECT(DISTINCT sa) AS members

CALL {{
  WITH members
  WITH CASE WHEN size(members) = 0 THEN [null] ELSE members END AS safe_members
  UNWIND safe_members AS state

  OPTIONAL MATCH (state)-[:IS_PARTY_TO_CONFLICT]->(c:Conflict)
  OPTIONAL MATCH (c)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)
  OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(actor)

  WITH
    state,
    COLLECT(DISTINCT c) AS conflict_list,
    COLLECT(DISTINCT actor) AS all_actors,
    COLLECT(DISTINCT {{conflict: c, type: ct.type}}) AS conflict_type_pairs

  WITH
    state,
    conflict_list,
    SIZE(conflict_list) AS total_conflicts,
    [conf IN conflict_list | conf.name] AS conflict_names,
    all_actors,
    conflict_type_pairs

  WITH
    state,
    conflict_list,
    total_conflicts,
    conflict_names,
    all_actors,
    conflict_type_pairs,
    [conf IN conflict_list |
      {{
        conflict_name: COALESCE(conf.name, "Unknown"),
        conflict_classification: COALESCE(
          [pair IN conflict_type_pairs WHERE pair.conflict = conf | pair.type][0],
          "Unclassified"
        ),
        conflict_overview: COALESCE(conf.overview, "No Overview Available"),
        applicable_ihl_law: COALESCE(conf.applicable_law, "Not Specified"),
        conflict_citation: COALESCE(conf.citation, "No Citation Available"),

        state_parties: CASE
          WHEN SIZE([
            p IN all_actors
            WHERE "StateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
          ]) = 0
            THEN "No state actors recorded"
          ELSE apoc.text.join(
            [
              p IN all_actors
              WHERE "StateActor" IN labels(p)
                AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
              | p.name
            ],
            ", "
          )
        END,

        non_state_parties: CASE
          WHEN SIZE([
            p IN all_actors
            WHERE "NonStateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
          ]) = 0
            THEN "No non-state actors recorded"
          ELSE apoc.text.join(
            [
              p IN all_actors
              WHERE "NonStateActor" IN labels(p)
                AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
              | p.name
            ],
            ", "
          )
        END
      }}
    ] AS conflict_details

  RETURN {{
    state_name: CASE WHEN state IS NULL THEN "NoMembersFound" ELSE COALESCE(state.name, "Unknown") END,
    state_UN_M49Code: CASE WHEN state IS NULL THEN "N/A" ELSE COALESCE(state.UN_M49Code, "N/A") END,
    total_conflicts: total_conflicts,
    conflict_names: conflict_names,
    conflict_details: conflict_details
  }} AS single_state_data
}}

WITH
  org,
  target_group_name,
  members,
  COLLECT(single_state_data) AS states_conflicts

WITH
  org,
  target_group_name,
  members,
  states_conflicts,
  apoc.coll.flatten([s IN states_conflicts | s.conflict_details]) AS conflict_details

WITH
  org,
  target_group_name,
  members,
  states_conflicts,
  conflict_details,
  apoc.coll.toSet([c IN conflict_details | c.conflict_name]) AS distinct_conflict_names

WITH
  org,
  target_group_name,
  members,
  states_conflicts,
  conflict_details,
  distinct_conflict_names,
  SIZE(members) AS total_members,
  SIZE(distinct_conflict_names) AS total_distinct_conflicts

////////////////////////////////////////////////////////////////////////
// 1. Sort members by conflict involvement using UNWIND + ORDER BY
////////////////////////////////////////////////////////////////////////

WITH
  org,
  target_group_name,
  total_members,
  conflict_details,
  distinct_conflict_names,
  states_conflicts,
  total_distinct_conflicts

UNWIND states_conflicts AS state_data
WITH
  org,
  target_group_name,
  total_members,
  conflict_details,
  distinct_conflict_names,
  total_distinct_conflicts,
  state_data
ORDER BY state_data.total_conflicts ASC

WITH
  org,
  target_group_name,
  total_members,
  conflict_details,
  distinct_conflict_names,
  total_distinct_conflicts,
  COLLECT(state_data) AS sorted_states

WITH
  org,
  target_group_name,
  total_members,
  conflict_details,
  distinct_conflict_names,
  total_distinct_conflicts,
  sorted_states,

  // Construct sorted member list
  
  "The '" + target_group_name + "' is defined as " + toString(total_members) + " members total, including: "
  + apoc.text.join([s IN sorted_states | s.state_name], ", ") + "." AS org_definition_text,

  [sc IN sorted_states WHERE sc.total_conflicts > 0 |
    {{
      state_name: sc.state_name,
      total_conflicts: sc.total_conflicts,
      conflict_names: sc.conflict_names
    }}
  ] AS breakdown_list

WITH
  org,
  target_group_name,
  total_members,
  conflict_details,
  distinct_conflict_names,
  total_distinct_conflicts,
  sorted_states,
  breakdown_list,
  org_definition_text,

  CASE
    WHEN org IS NULL THEN
      "No organization named '" + target_group_name + "' was found in the database."
    WHEN total_members = 0 THEN
      "The organization '" + target_group_name + "' was found, but currently has no recorded StateActor members in the database."
    WHEN total_distinct_conflicts = 0 THEN
      "According to RULAC, there are currently no recorded armed conflicts involving any of the "
      + toString(total_members) + " members of '" + target_group_name + "'."
    ELSE
      "According to RULAC, the " + target_group_name + " member states currently party to the fewest conflicts are: "
      + apoc.text.join(
          [ state_conflict IN breakdown_list | 
            toString(state_conflict.total_conflicts)
            + " conflict(s) involving "
            + state_conflict.state_name
            + ": "
            + apoc.text.join(state_conflict.conflict_names, ", ")
          ], "; ") + "."
  END AS conflict_summary_text

RETURN {{
  summary: org_definition_text + " " + conflict_summary_text,
  conflict_details: conflict_details
}} AS RULAC_research



## Example 10b (Ranking most  conflict involvement by organization member and filtering by conflict type )
Research Question: "Which African Union countries have been involved in the most or highest number of non-international armed conflicts (NIACs) worldwide?"
Generated Query:
////////////////////////////////////////////////////////////////
// Example: Ranking African Union Countries by NIAC Involvement
////////////////////////////////////////////////////////////////

// Define the target group and conflict types

WITH 
  "African Union" AS target_group_name,
  ["Non-International Armed Conflict (NIAC)"] AS target_conflict_types  // Conflict types to filter

// Match African Union organization and its members

OPTIONAL MATCH (org:Organization {{name: target_group_name}})
OPTIONAL MATCH (sa:StateActor)-[:IS_MEMBER]->(org)

WITH
  org,
  target_group_name,
  target_conflict_types,  // ✅ Pass the variable explicitly
  COLLECT(DISTINCT sa) AS members

CALL {{
  WITH members, target_conflict_types  // ✅ Ensure the variable is passed in
  WITH CASE WHEN SIZE(members) = 0 THEN [null] ELSE members END AS safe_members, target_conflict_types
  UNWIND safe_members AS state

  OPTIONAL MATCH (state)-[:IS_PARTY_TO_CONFLICT]->(c:Conflict)
  OPTIONAL MATCH (c)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)
  WHERE ct.type IN target_conflict_types  // ✅ Ensure conflict type filter works

  OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(actor)

  WITH
    state,
    target_conflict_types,  // ✅ Pass conflict types down
    COLLECT(DISTINCT c) AS conflict_list,
    COLLECT(DISTINCT actor) AS all_actors,
    COLLECT(DISTINCT {{conflict: c, type: ct.type}}) AS conflict_type_pairs

  WITH
    state,
    conflict_list,
    target_conflict_types,
    SIZE(conflict_list) AS total_conflicts,
    [conf IN conflict_list | conf.name] AS conflict_names,
    all_actors,
    conflict_type_pairs,

    [conf IN conflict_list |
      {{
        conflict_name: COALESCE(conf.name, "Unknown"),
        conflict_classification: COALESCE(
          [pair IN conflict_type_pairs WHERE pair.conflict = conf | pair.type][0],
          "Unclassified"
        ),
        conflict_overview: COALESCE(conf.overview, "No Overview Available"),
        applicable_ihl_law: COALESCE(conf.applicable_law, "Not Specified"),
        conflict_citation: COALESCE(conf.citation, "No Citation Available"),

        state_parties: CASE
          WHEN SIZE([
            p IN all_actors
            WHERE "StateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
          ]) = 0
            THEN "No state actors recorded"
          ELSE apoc.text.join(
            [
              p IN all_actors
              WHERE "StateActor" IN labels(p)
                AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
              | p.name
            ],
            ", "
          )
        END,

        non_state_parties: CASE
          WHEN SIZE([
            p IN all_actors
            WHERE "NonStateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
          ]) = 0
            THEN "No non-state actors recorded"
          ELSE apoc.text.join(
            [
              p IN all_actors
              WHERE "NonStateActor" IN labels(p)
                AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
              | p.name
            ],
            ", "
          )
        END
      }}
    ] AS conflict_details

  RETURN {{
    state_name: CASE WHEN state IS NULL THEN "NoMembersFound" ELSE COALESCE(state.name, "Unknown") END,
    state_UN_M49Code: CASE WHEN state IS NULL THEN "N/A" ELSE COALESCE(state.UN_M49Code, "N/A") END,
    total_conflicts: total_conflicts,
    conflict_names: conflict_names,
    conflict_details: conflict_details
  }} AS single_state_data
}}

WITH
  org,
  target_group_name,
  target_conflict_types,
  members,
  COLLECT(single_state_data) AS states_conflicts

WITH
  org,
  target_group_name,
  target_conflict_types,
  members,
  states_conflicts,
  apoc.coll.flatten([s IN states_conflicts | s.conflict_details]) AS conflict_details

WITH
  org,
  target_group_name,
  target_conflict_types,
  members,
  states_conflicts,
  conflict_details,
  apoc.coll.toSet([c IN conflict_details | c.conflict_name]) AS distinct_conflict_names

WITH
  org,
  target_group_name,
  target_conflict_types,
  members,
  states_conflicts,
  conflict_details,
  distinct_conflict_names,
  SIZE(members) AS total_members,
  SIZE(distinct_conflict_names) AS total_distinct_conflicts

////////////////////////////////////////////////////////////////////////
// 1. Sort members by conflict involvement using UNWIND + ORDER BY
////////////////////////////////////////////////////////////////////////

WITH
  org,
  target_group_name,
  total_members,
  target_conflict_types,
  conflict_details,
  distinct_conflict_names,
  states_conflicts,
  total_distinct_conflicts

UNWIND states_conflicts AS state_data
WITH
  org,
  target_group_name,
  total_members,
  target_conflict_types,
  conflict_details,
  distinct_conflict_names,
  total_distinct_conflicts,
  state_data
ORDER BY state_data.total_conflicts DESC  // ✅ Rank by most NIAC conflicts

WITH
  org,
  target_group_name,
  total_members,
  target_conflict_types,
  conflict_details,
  distinct_conflict_names,
  total_distinct_conflicts,
  COLLECT(state_data) AS sorted_states

WITH
  org,
  target_group_name,
  total_members,
  target_conflict_types,
  conflict_details,
  distinct_conflict_names,
  total_distinct_conflicts,
  sorted_states,
  "The '" + target_group_name + "' is defined as " + toString(total_members) + " members total, including: "
  + apoc.text.join([s IN sorted_states | s.state_name], ", ") + "." AS org_definition_text,

  [sc IN sorted_states WHERE sc.total_conflicts > 0 |
    {{
      state_name: sc.state_name,
      total_conflicts: sc.total_conflicts,
      conflict_names: sc.conflict_names
    }}
  ] AS breakdown_list

RETURN {{
  summary: org_definition_text + " " + conflict_summary_text,
  conflict_details: conflict_details
}} AS RULAC_research_results




## Example 11 (Counting conflicts by conflict type in region)
Research Question: "How many Military Occupations are taking place i Africa?"
Generated Query:
////////////////////////////////////////////////////////////////////////
// EXAMPLE 11 (Counting conflicts by conflict type in region):
//
// This template retrieves the count of conflicts of a specific type
// ("Military Occupation") taking place in a specified region
// (e.g., Africa = code "002").
//
// To reuse this template, change the top WITH variables:
//   1) target_region_code       (e.g., "002" for Africa)
//   2) target_conflict_type     (e.g., "Military Occupation")
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// 0. Set up our parameters
////////////////////////////////////////////////////////////////////////

WITH
  "002" AS target_region_code,
  "Military Occupation" AS target_conflict_type

////////////////////////////////////////////////////////////////////////
// 1. OPTIONAL MATCH the GeoRegion node with the given M49 code
//    - If no matching GeoRegion node is found, 'gr' will be null,
//      but we still keep one row for fallback.
////////////////////////////////////////////////////////////////////////

OPTIONAL MATCH (gr:GeoRegion {{UN_M49Code: target_region_code}})

////////////////////////////////////////////////////////////////////////
// 2. OPTIONAL MATCH any Country nodes that belong to that region
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (co:Country)-[:BELONGS_TO]->(gr)

////////////////////////////////////////////////////////////////////////
// 3. OPTIONAL MATCH conflicts that take place in those countries
//    and are classified as the target conflict type.
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (co)<-[:IS_TAKING_PLACE_IN_COUNTRY]-(c:Conflict)
       -[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)
WHERE ct.type = target_conflict_type

////////////////////////////////////////////////////////////////////////
// 4. OPTIONAL MATCH all other parties to these conflicts (state & non-state)
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c)-[:IS_PARTY_TO_CONFLICT]-(actor)

////////////////////////////////////////////////////////////////////////
// 5. Aggregate the conflicts and actors
////////////////////////////////////////////////////////////////////////
WITH
  // If the GeoRegion node wasn't found, default to 'target_region_name'
  COALESCE(gr.name, "Africa") AS region_name,
  COALESCE(gr.UN_M49Code, target_region_code) AS geo_region_UN_M49Code,
  COALESCE(COLLECT(DISTINCT c), []) AS conflicts,
  COALESCE(COLLECT(DISTINCT actor), []) AS all_actors,
  target_conflict_type AS classification,
  COALESCE(COLLECT(DISTINCT co), []) AS countries

////////////////////////////////////////////////////////////////////////
// 6. Count the total number of conflicts and countries
////////////////////////////////////////////////////////////////////////
WITH
  region_name,
  geo_region_UN_M49Code,
  conflicts,
  all_actors,
  classification,
  countries,
  COALESCE(SIZE(conflicts), 0) AS total_conflicts,
  COALESCE(SIZE(countries), 0) AS total_countries,
  [country IN countries | country.name] AS sorted_region_country_names

////////////////////////////////////////////////////////////////////////
// 7. Build a detailed conflict map array
////////////////////////////////////////////////////////////////////////
WITH
  region_name,
  geo_region_UN_M49Code,
  total_countries,
  sorted_region_country_names,
  total_conflicts,
  classification,
  [co IN conflicts | co.name] AS conflict_name_list,

  [conflict IN conflicts |
    {{
      conflict_name: COALESCE(conflict.name, "Unknown"),
      conflict_classification: classification,
      conflict_overview: COALESCE(conflict.overview, "No Overview Available"),
      applicable_ihl_law: COALESCE(conflict.applicable_law, "Not Specified"),
      conflict_citation: COALESCE(conflict.citation, "No Citation Available"),

      state_parties: CASE
        WHEN SIZE([
          p IN all_actors
          WHERE "StateActor" IN labels(p)
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
        ]) = 0
          THEN "No state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors
            WHERE "StateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
            | p.name
          ],
          ", "
        )
      END,

      non_state_parties: CASE
        WHEN SIZE([
          p IN all_actors
          WHERE "NonStateActor" IN labels(p)
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
        ]) = 0
          THEN "No non-state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors
            WHERE "NonStateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
            | p.name
          ],
          ", "
        )
      END
    }}
  ] AS conflict_details

////////////////////////////////////////////////////////////////////////
// 8. Build a dynamic summary about the total and classification breakdown
////////////////////////////////////////////////////////////////////////
WITH
  region_name,
  geo_region_UN_M49Code,
  total_countries,
  sorted_region_country_names,
  total_conflicts,
  classification,
  conflict_name_list,
  conflict_details,

  region_name + " is defined by UN M49 code " + geo_region_UN_M49Code +
  " and includes " + toString(total_countries) + " countries total: " +
  apoc.text.join(sorted_region_country_names, ", ") + "." AS region_summary,

  CASE
    WHEN total_conflicts = 0 THEN
      "According to RULAC, there are currently no recorded '"
      + classification + "' conflicts taking place in " + region_name + "."
    ELSE
      "According to RULAC, there are currently "
      + toString(total_conflicts) + " '"
      + classification + "' conflict(s) taking place in "
      + region_name + ": " + apoc.text.join(conflict_name_list, ", ") + "."
  END AS conflict_summary_text

////////////////////////////////////////////////////////////////////////
// 9. Return summary and detailed conflicts as RULAC_research
////////////////////////////////////////////////////////////////////////
RETURN {{
  summary: region_summary + " " + conflict_summary_text,
  conflict_details: CASE
    WHEN total_conflicts = 0 THEN []
    ELSE conflict_details
  END
}} AS RULAC_research


Example 12. Comparing conflicts between 2 organizations
Research Question: "how would you compare conflicts involving African Union and European Union member states?"
Generated Query:
////////////////////////////////////////////////////////////////////////
// EXAMPLE (Compare conflicts involving African Union and European Union member states):
//
// This template compares the conflicts involving African Union and European Union member states.
// It retrieves the total number of conflicts, a list of all distinct conflict names,
// a breakdown by each member state, and the actual names of all member states in parentheses.
//
// To reuse this template, simply adjust the target_group_name variables if needed.
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// 0. Define the organization names
////////////////////////////////////////////////////////////////////////
WITH ["African Union", "European Union"] AS target_group_names

////////////////////////////////////////////////////////////////////////
// 1. OPTIONAL MATCH the Organization nodes
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (org:Organization)
WHERE org.name IN target_group_names

////////////////////////////////////////////////////////////////////////
// 2. OPTIONAL MATCH StateActor nodes that are members of these organizations
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (sa:StateActor)-[:IS_MEMBER]->(org)

////////////////////////////////////////////////////////////////////////
// 3. Collect all member states in a single list
////////////////////////////////////////////////////////////////////////
WITH
  org,
  target_group_names,
  COLLECT(DISTINCT sa) AS members

////////////////////////////////////////////////////////////////////////
// 4. Match conflicts involving these member states
////////////////////////////////////////////////////////////////////////
MATCH (c:Conflict)-[:IS_PARTY_TO_CONFLICT]-(sa)
WHERE sa IN members

////////////////////////////////////////////////////////////////////////
// 5. OPTIONAL MATCH the classification of these conflicts
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)

////////////////////////////////////////////////////////////////////////
// 6. OPTIONAL MATCH all other parties to these conflicts
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c)-[r:IS_PARTY_TO_CONFLICT]-(actor)

////////////////////////////////////////////////////////////////////////
// 7. Assign group_name based on the organization name
////////////////////////////////////////////////////////////////////////
WITH
  org.name AS group_name,
  c,
  ct,
  COLLECT(
    DISTINCT {{
      name: actor.name,
      labels: labels(actor),
      relationship_type: type(r)
    }}
  ) AS conflict_parties

////////////////////////////////////////////////////////////////////////
// 8. Create conflict_detail map
////////////////////////////////////////////////////////////////////////
WITH
  group_name,
  {{
    conflict_name: COALESCE(c.name, "Unknown"),
    conflict_classification: ct.type,
    conflict_overview: COALESCE(c.overview, "No Overview Available"),
    applicable_ihl_law: COALESCE(c.applicable_law, "Not Specified"),
    conflict_citation: COALESCE(c.citation, "No Citation Available"),
    state_parties: apoc.text.join([p IN conflict_parties WHERE "StateActor" IN p.labels | p.name], ", "),
    non_state_parties: apoc.text.join([p IN conflict_parties WHERE "NonStateActor" IN p.labels | p.name], ", ")
  }} AS conflict_detail

////////////////////////////////////////////////////////////////////////
// 9. Aggregate distinct conflicts per group
////////////////////////////////////////////////////////////////////////
WITH
  group_name,
  COLLECT(DISTINCT conflict_detail) AS conflicts_per_group

////////////////////////////////////////////////////////////////////////
// 10. Calculate total conflicts per group
////////////////////////////////////////////////////////////////////////
WITH
  group_name,
  conflicts_per_group,
  SIZE(conflicts_per_group) AS total_conflicts,
  [conflict IN conflicts_per_group | conflict.conflict_name] AS conflict_names

////////////////////////////////////////////////////////////////////////
// 11. Collect group_conflict_summary ensuring unique entries per group
////////////////////////////////////////////////////////////////////////
WITH
  COLLECT({{
    group_name: group_name,
    total_conflicts: total_conflicts,
    conflict_names: conflict_names,
    conflicts_per_group: conflicts_per_group
  }}) AS group_conflict_summary

////////////////////////////////////////////////////////////////////////
// 12. Determine the maximum number of conflicts
////////////////////////////////////////////////////////////////////////
WITH
  group_conflict_summary,
  apoc.coll.max([g IN group_conflict_summary | g.total_conflicts]) AS max_conflicts

////////////////////////////////////////////////////////////////////////
// 13. Collect all groups with the maximum number of conflicts (to handle ties)
////////////////////////////////////////////////////////////////////////
WITH
  group_conflict_summary,
  max_conflicts,
  [g IN group_conflict_summary WHERE g.total_conflicts = max_conflicts] AS most_conflicted_groups,
  apoc.coll.flatten([
    group IN group_conflict_summary |
    group.group_name + " includes state actor involvement in " +
    toString(group.total_conflicts) + " conflict(s): " +
    apoc.text.join(apoc.coll.toSet(group.conflict_names), ", ")
  ]) AS breakdown,
  apoc.coll.flatten([group IN group_conflict_summary | group.conflicts_per_group]) AS conflict_details

////////////////////////////////////////////////////////////////////////
// 14. Assign the summary text using a separate WITH clause
////////////////////////////////////////////////////////////////////////
WITH
  group_conflict_summary,
  max_conflicts,
  most_conflicted_groups,
  breakdown,
  conflict_details,
  CASE
    WHEN SIZE(most_conflicted_groups) = 1 THEN
      "According to RULAC, the group with the most state actor involvement in armed conflicts is " +
      most_conflicted_groups[0].group_name +
      ", with state actors engaged in " + toString(max_conflicts) + " total conflicts."
    ELSE
      "According to RULAC, " +
      apoc.text.join([g IN most_conflicted_groups | g.group_name], " and ") +
      " groups are equally involved in " +
      toString(max_conflicts) + " total conflicts."
  END AS summary_text

////////////////////////////////////////////////////////////////////////
// 15. Return summary and detailed conflicts as RULAC_research
////////////////////////////////////////////////////////////////////////
RETURN {{
  summary: summary_text + " Breakdown by group: " +
            apoc.text.join(breakdown, "; "),
  conflict_details: conflict_details
}} AS RULAC_research



Example 12B. Comparing conflicts by type and between 2 organizations
Research Question: "Are African Union member states more frequently involved in NIACS compared to European Union member states?"
Generated Query:
////////////////////////////////////////////////////////////////////////
// EXAMPLE 12.b (Counting conflicts by conflict type across 2 organization groups):
//
// This template compares the count of conflicts of a specific type
// (e.g. "Military Occupation") taking place in a specified organization (EU, AU, NATO, etc.)
//
// To reuse this template, change the top WITH variables:
//   1) target_group_names       (e.g., "European Union" for EU, and "African Union" for AU)
//   2) target_conflict_type     (e.g., "Military Occupation")
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// 0. Set up our parameters
////////////////////////////////////////////////////////////////////////

WITH ["African Union", "European Union"] AS target_group_names,
     "Non-International Armed Conflict (NIAC)" AS target_conflict_type

////////////////////////////////////////////////////////////////////////
// 1. OPTIONAL MATCH the Organization nodes
////////////////////////////////////////////////////////////////////////

OPTIONAL MATCH (org:Organization)
WHERE org.name IN target_group_names

////////////////////////////////////////////////////////////////////////
// 2. OPTIONAL MATCH StateActor nodes that are members of these organizations
////////////////////////////////////////////////////////////////////////

OPTIONAL MATCH (sa:StateActor)-[:IS_MEMBER]->(org)

////////////////////////////////////////////////////////////////////////
// 3. Collect all member states in a single list
////////////////////////////////////////////////////////////////////////

WITH
  org,
  target_group_names,
  target_conflict_type,
  COLLECT(DISTINCT sa) AS members

////////////////////////////////////////////////////////////////////////
// 4. Match conflicts involving these member states
////////////////////////////////////////////////////////////////////////

MATCH (c:Conflict)-[:IS_PARTY_TO_CONFLICT]-(sa)
WHERE sa IN members

////////////////////////////////////////////////////////////////////////
// 5. OPTIONAL MATCH the classification of these conflicts
////////////////////////////////////////////////////////////////////////

OPTIONAL MATCH (c)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)

////////////////////////////////////////////////////////////////////////
// 6. OPTIONAL MATCH all other parties to these conflicts
////////////////////////////////////////////////////////////////////////

OPTIONAL MATCH (c)-[r:IS_PARTY_TO_CONFLICT]-(actor)

////////////////////////////////////////////////////////////////////////
// 7. Assign group_name based on the organization name
////////////////////////////////////////////////////////////////////////

WITH
  org.name AS group_name,
  target_conflict_type,
  c,
  ct,
  COLLECT(
    DISTINCT {{
      name: actor.name,
      labels: labels(actor),
      relationship_type: type(r)
    }}
  ) AS conflict_parties

////////////////////////////////////////////////////////////////////////
// 8. Create conflict_detail map
////////////////////////////////////////////////////////////////////////

WITH
  group_name,
  target_conflict_type,
  {{
    conflict_name: COALESCE(c.name, "Unknown"),
    conflict_classification: ct.type,
    conflict_overview: COALESCE(c.overview, "No Overview Available"),
    applicable_ihl_law: COALESCE(c.applicable_law, "Not Specified"),
    conflict_citation: COALESCE(c.citation, "No Citation Available"),
    state_parties: apoc.text.join([p IN conflict_parties WHERE "StateActor" IN p.labels | p.name], ", "),
    non_state_parties: apoc.text.join([p IN conflict_parties WHERE "NonStateActor" IN p.labels | p.name], ", ")
  }} AS conflict_detail
WHERE ct.type = target_conflict_type

////////////////////////////////////////////////////////////////////////
// 9. Aggregate distinct conflicts per group
////////////////////////////////////////////////////////////////////////

WITH
  group_name,
  target_conflict_type,
  COLLECT(DISTINCT conflict_detail) AS conflicts_per_group

////////////////////////////////////////////////////////////////////////
// 10. Calculate total conflicts per group
////////////////////////////////////////////////////////////////////////

WITH
  group_name,
  target_conflict_type,
  conflicts_per_group,
  SIZE(conflicts_per_group) AS total_conflicts,
  [conflict IN conflicts_per_group | conflict.conflict_name] AS conflict_names

////////////////////////////////////////////////////////////////////////
// 11. Collect group_conflict_summary ensuring unique entries per group
////////////////////////////////////////////////////////////////////////

WITH
  COLLECT({{
    group_name: group_name,
    total_conflicts: total_conflicts,
    conflict_names: conflict_names,
    conflicts_per_group: conflicts_per_group
  }}) AS group_conflict_summary,
  target_conflict_type

////////////////////////////////////////////////////////////////////////
// 12. Determine the maximum number of conflicts
////////////////////////////////////////////////////////////////////////

WITH
  group_conflict_summary,
  target_conflict_type,
  apoc.coll.max([g IN group_conflict_summary | g.total_conflicts]) AS max_conflicts

////////////////////////////////////////////////////////////////////////
// 13. Collect all groups with the maximum number of conflicts (to handle ties)
////////////////////////////////////////////////////////////////////////

WITH
  group_conflict_summary,
  target_conflict_type,
  max_conflicts,
  [g IN group_conflict_summary WHERE g.total_conflicts = max_conflicts] AS most_conflicted_groups,
  apoc.coll.flatten([
    group IN group_conflict_summary |
    group.group_name + " includes state actor involvement in " +
    toString(group.total_conflicts) + " conflict(s): " +
    apoc.text.join(apoc.coll.toSet(group.conflict_names), ", ")
  ]) AS breakdown,
  apoc.coll.flatten([group IN group_conflict_summary | group.conflicts_per_group]) AS conflict_details

////////////////////////////////////////////////////////////////////////
// 14. Assign the summary text using a separate WITH clause
////////////////////////////////////////////////////////////////////////

WITH
  group_conflict_summary,
  target_conflict_type,
  max_conflicts,
  most_conflicted_groups,
  breakdown,
  conflict_details,
  CASE
    WHEN SIZE(most_conflicted_groups) = 1 THEN
      "According to RULAC, in a comparison between " +
      group_conflict_summary[0].group_name + " and " +
      group_conflict_summary[1].group_name + ", the group with the most state actor involvement in '" +
      target_conflict_type + "' conflicts is " +
      most_conflicted_groups[0].group_name +
      ", with state actors engaged in " + toString(max_conflicts) + " total conflicts."
    ELSE
      "According to RULAC, in a comparison between " +
      group_conflict_summary[0].group_name + " and " +
      group_conflict_summary[1].group_name + ", " +
      apoc.text.join([g IN most_conflicted_groups | g.group_name], " and ") +
      " groups are equally involved in " +
      toString(max_conflicts) + " total '" + target_conflict_type + "' conflicts."
  END AS summary_text

////////////////////////////////////////////////////////////////////////
// 15. Return summary and detailed conflicts as RULAC_research
////////////////////////////////////////////////////////////////////////

RETURN {{
  summary: summary_text + " Breakdown by group: " +
            apoc.text.join(breakdown, "; "),
  conflict_details: conflict_details
}} AS RULAC_research






Example 13. Compare conflict involvement across different countries and their neighbors
Research Question: "How many armed conflicts is Syria currently involved in compared to its neighboring countries?"
Generated Query:
////////////////////////////////////////////////////////////////////////
// EXAMPLE: Compare conflict involvement across different countries and their neighbors
//
// RESEARCH QUESTION:
// "How many armed conflicts is Syria currently involved in compared to its neighboring countries?"
//
// CONCEPT OF NEIGHBORING COUNTRIES:
// - A neighboring country is defined as a country that shares a **direct land border** with another country.
// - We use **UN M49 country codes** to ensure accurate identification of Syria and its neighboring states.
//
// USAGE NOTES:
// - Ensure the list of neighboring countries is correctly defined based on official geographic borders.
// - If modifying this for a different country, update the **country_codes** list accordingly.
// - This query retrieves the total number of armed conflicts each country is involved in and compares them.
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// 0. Define Parameters: Syria and Its Neighboring Countries
////////////////////////////////////////////////////////////////////////

WITH [
    "760", // Syria (Main country of interest)
    "400", // Jordan (Shares a southern border with Syria)
    "376", // Lebanon (Shares a western border with Syria)
    "792", // Turkey (Shares a northern border with Syria)
    "368", // Iraq (Shares an eastern border with Syria)
    "376"  // Israel (Shares a southwestern border with Syria)
] AS country_codes


// Match conflicts involving Syria and its neighboring countries
MATCH (c:Conflict)-[:IS_PARTY_TO_CONFLICT]-(sa:StateActor)
WHERE sa.UN_M49Code IN country_codes
OPTIONAL MATCH (c)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)
OPTIONAL MATCH (c)-[r:IS_PARTY_TO_CONFLICT]-(actor)
WITH
  sa.name AS country_name,
  sa.UN_M49Code AS country_UN_M49Code,
  c,
  ct,
  COLLECT(
    DISTINCT {{
      name: actor.name,
      labels: labels(actor),
      relationship_type: type(r)
    }}
  ) AS conflict_parties
WITH
  country_name,
  country_UN_M49Code,
  {{
    conflict_name: c.name,
    conflict_classification: ct.type,
    conflict_overview: c.overview,
    applicable_ihl_law: c.applicable_law,
    conflict_citation: c.citation,
    state_parties: apoc.text.join([p IN conflict_parties WHERE "StateActor" IN p.labels | p.name], ", "),
    non_state_parties: apoc.text.join([p IN conflict_parties WHERE "NonStateActor" IN p.labels | p.name], ", ")
  }} AS conflict_detail
WITH
  country_name,
  country_UN_M49Code,
  COLLECT(conflict_detail) AS conflicts_per_country
WITH
  country_name,
  country_UN_M49Code,
  conflicts_per_country,
  size(conflicts_per_country) AS total_conflicts
WITH
  COLLECT({{
    country_name: country_name,
    country_UN_M49Code: country_UN_M49Code,
    total_conflicts: total_conflicts,
    conflict_names: [conflict IN conflicts_per_country | conflict.conflict_name],
    conflicts_per_country: conflicts_per_country
  }}) AS country_conflict_summary
WITH
  country_conflict_summary,
  apoc.coll.max([c IN country_conflict_summary | c.total_conflicts]) AS max_conflicts,
  [c IN country_conflict_summary WHERE c.total_conflicts = apoc.coll.max([c IN country_conflict_summary | c.total_conflicts])] AS most_conflicted_countries,
  apoc.coll.flatten([country IN country_conflict_summary | country.country_name + " (UN M49 code: " + country.country_UN_M49Code + ") is a state party to " + toString(country.total_conflicts) + " conflict(s): " + apoc.text.join(country.conflict_names, ", ")]) AS breakdown,
  apoc.coll.flatten([conflict IN country_conflict_summary | conflict.conflicts_per_country]) AS conflict_details
RETURN {{
  summary: CASE
    WHEN size(most_conflicted_countries) = 1 THEN
      "According to RULAC, in a comparison between Syria and its neighboring countries, the country currently party to the most distinct armed conflicts is " + most_conflicted_countries[0].country_name + ", being a state party to " + toString(max_conflicts) + " total distinct conflicts. Breakdown by country: " + apoc.text.join(breakdown, "; ")
    ELSE
      "According to RULAC, in a comparison between Syria and its neighboring countries, both Syria and its neighboring countries are equally party to " + toString(max_conflicts) + " total distinct conflicts. Breakdown by country: " + apoc.text.join(breakdown, "; ")
  END,
  conflict_details: conflict_details
}} AS RULAC_research






Research Question: "globally, how many interantional armed conflicts is taking place in the world?"
Generated Query:
////////////////////////////////////////////////////////////////////////
// EXAMPLE 13b (Global conflict details by conflict type and taking place in world, reporting by region):
//
// This template retrieves the count of conflicts of a specific type
// ("International Armed Conflict (IAC)") taking place in the world
// (UN M49 code "001"). It returns detailed information about each conflict,
// including the region, classification, overview, applicable IHL, parties, etc.
//
// To reuse this template, change the top WITH variables:
//   1) target_region_code       (e.g., "001" for World)
//   2) target_conflict_type     (e.g., "International Armed Conflict (IAC)")
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// 0. Set up our parameters
////////////////////////////////////////////////////////////////////////
WITH
  "001" AS target_region_code,
  "International Armed Conflict (IAC)" AS target_conflict_type

////////////////////////////////////////////////////////////////////////
// 1. OPTIONAL MATCH the GeoRegion node with the given M49 code
//    - If no matching GeoRegion node is found, 'gr' will be null,
//      but we still keep one row for fallback.
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (gr:GeoRegion {{UN_M49Code: target_region_code}})

////////////////////////////////////////////////////////////////////////
// 2. OPTIONAL MATCH any Country nodes that belong to that region
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (co:Country)-[:BELONGS_TO]->(gr)

////////////////////////////////////////////////////////////////////////
// 3. OPTIONAL MATCH conflicts that take place in those countries
//    and are classified as the target conflict type.
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (co)<-[:IS_TAKING_PLACE_IN_COUNTRY]-(c:Conflict)
       -[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)
WHERE ct.type = target_conflict_type

////////////////////////////////////////////////////////////////////////
// 4. OPTIONAL MATCH all other parties to these conflicts (state & non-state)
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c)-[r:IS_PARTY_TO_CONFLICT]-(actor)

////////////////////////////////////////////////////////////////////////
// 5. Aggregate the conflicts and actors
////////////////////////////////////////////////////////////////////////
WITH
  // If the GeoRegion node wasn't found, default to 'target_region_name'
  COALESCE(gr.name, "World") AS region_name,
  COALESCE(gr.UN_M49Code, target_region_code) AS geo_region_UN_M49Code,
  COALESCE(COLLECT(DISTINCT c), []) AS conflicts,
  COALESCE(COLLECT(DISTINCT actor), []) AS all_actors,
  target_conflict_type AS classification,
  COALESCE(COLLECT(DISTINCT co), []) AS countries

////////////////////////////////////////////////////////////////////////
// 6. Count the total number of conflicts and countries
////////////////////////////////////////////////////////////////////////
WITH
  region_name,
  geo_region_UN_M49Code,
  conflicts,
  all_actors,
  classification,
  countries,
  COALESCE(SIZE(conflicts), 0) AS total_conflicts,
  COALESCE(SIZE(countries), 0) AS total_countries,
  [country IN countries | country.name] AS sorted_region_country_names

////////////////////////////////////////////////////////////////////////
// 7. Build a detailed conflict map array
////////////////////////////////////////////////////////////////////////
WITH
  region_name,
  geo_region_UN_M49Code,
  total_countries,
  sorted_region_country_names,
  total_conflicts,
  classification,
  [co IN conflicts | co.name] AS conflict_name_list,

  [conflict IN conflicts |
    {{
      conflict_name: COALESCE(conflict.name, "Unknown"),
      conflict_classification: classification,
      conflict_overview: COALESCE(conflict.overview, "No Overview Available"),
      applicable_ihl_law: COALESCE(conflict.applicable_law, "Not Specified"),
      conflict_citation: COALESCE(conflict.citation, "No Citation Available"),

      state_parties: CASE
        WHEN SIZE([
          p IN all_actors
          WHERE "StateActor" IN labels(p)
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
        ]) = 0
          THEN "No state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors
            WHERE "StateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
            | p.name
          ],
          ", "
        )
      END,

      non_state_parties: CASE
        WHEN SIZE([
          p IN all_actors
          WHERE "NonStateActor" IN labels(p)
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
        ]) = 0
          THEN "No non-state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors
            WHERE "NonStateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conflict)
            | p.name
          ],
          ", "
        )
      END
    }}
  ] AS conflict_details

////////////////////////////////////////////////////////////////////////
// 8. Build a dynamic summary about the total and classification breakdown
////////////////////////////////////////////////////////////////////////
WITH
  region_name,
  geo_region_UN_M49Code,
  total_countries,
  sorted_region_country_names,
  total_conflicts,
  classification,
  conflict_name_list,
  conflict_details,

  region_name + " is defined by UN M49 code " + geo_region_UN_M49Code +
  " and includes " + toString(total_countries) + " countries total: " +
  apoc.text.join(sorted_region_country_names, ", ") + "." AS region_summary,

  CASE
    WHEN total_conflicts = 0 THEN
      "According to RULAC, there are currently no recorded '"
      + classification + "' conflicts taking place in " + region_name + "."
    ELSE
      "According to RULAC, there are currently "
      + toString(total_conflicts) + " '"
      + classification + "' conflict(s) taking place in "
      + region_name + ": " + apoc.text.join(conflict_name_list, ", ") + "."
  END AS conflict_summary_text

////////////////////////////////////////////////////////////////////////
// 9. Return summary and detailed conflicts as RULAC_research
////////////////////////////////////////////////////////////////////////
RETURN {{
  summary: region_summary + " " + conflict_summary_text,
  conflict_details: CASE
    WHEN total_conflicts = 0 THEN []
    ELSE conflict_details
  END
}} AS RULAC_research





Example 14. Conflict lookup by non-state actor involvement
Research Question: "What are the main conflicts linked to the Revolutionary Armed Forces of Colombia?"
Generated Query:
////////////////////////////////////////////////////////////////////////
// EXAMPLE 14 (Conflict lookup by non-state actor, and default data shape if no results):
//
// This template retrieves conflicts involving a specific non-state actor
// (e.g., "FARC") by matching the actor's name or aliases.
// It returns detailed information about each conflict, including the
// classification, overview, applicable IHL, parties, etc.
//
// To reuse this template, change the top WITH variable:
//   1) actor_name_and_aliases which is composed of alternate spelling of the actor name, ie. alias  (e.g., ["Revolutionary Armed Forces of Colombia (FARC)", "Revolutionary Armed Forces", "FARC", "Fuerzas Armadas Revolucionarias de Colombia"])
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// 0. Set up our parameters
////////////////////////////////////////////////////////////////////////
WITH ["Revolutionary Armed Forces of Colombia (FARC)", "Revolutionary Armed Forces", "FARC", "Fuerzas Armadas Revolucionarias de Colombia"] AS actor_name_and_aliases

////////////////////////////////////////////////////////////////////////
// 1. OPTIONAL MATCH the Conflict nodes that involve the specified non-state actor
//    - If no matching Conflict nodes are found, 'c' will be null,
//      but we still keep one row for fallback.
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c:Conflict)-[r:IS_PARTY_TO_CONFLICT]-(actor)
WHERE any(name_alias IN actor_name_and_aliases WHERE toLower(actor.name) CONTAINS toLower(name_alias))
   OR any(name_alias IN actor_name_and_aliases WHERE any(alias IN actor.aliases WHERE toLower(alias) CONTAINS toLower(name_alias)))

////////////////////////////////////////////////////////////////////////
// 2. OPTIONAL MATCH the classification of these conflicts
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(ct:ConflictType)

////////////////////////////////////////////////////////////////////////
// 3. OPTIONAL MATCH all other parties to these conflicts
////////////////////////////////////////////////////////////////////////
OPTIONAL MATCH (c)-[r2:IS_PARTY_TO_CONFLICT]-(other_actor)

////////////////////////////////////////////////////////////////////////
// 4. Aggregate the conflicts and actors
////////////////////////////////////////////////////////////////////////
WITH
  actor_name_and_aliases,
  COALESCE(COLLECT(DISTINCT c), []) AS conflicts,
  COALESCE(COLLECT(DISTINCT other_actor), []) AS all_actors,
  COALESCE(COLLECT(DISTINCT {{conflict: c, type: ct.type}}), []) AS conflict_types

////////////////////////////////////////////////////////////////////////
// 5. Count the total number of conflicts
////////////////////////////////////////////////////////////////////////
WITH
  actor_name_and_aliases,
  conflicts,
  all_actors,
  conflict_types,
  COALESCE(SIZE(conflicts), 0) AS total_conflicts

////////////////////////////////////////////////////////////////////////
// 6. Derive classification breakdown (IAC, NIAC, Occupation)
////////////////////////////////////////////////////////////////////////
WITH
  actor_name_and_aliases,
  total_conflicts,
  conflicts,
  all_actors,
  conflict_types,

  // Number of conflicts classified as IAC
  SIZE([
    conf IN conflicts
    WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "International Armed Conflict (IAC)"}})
    }}
  ]) AS total_IAC,

  // Number of conflicts classified as NIAC
  SIZE([
    conf IN conflicts
    WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "Non-International Armed Conflict (NIAC)"}})
    }}
  ]) AS total_NIAC,

  // Number of conflicts classified as Military Occupation
  SIZE([
    conf IN conflicts
    WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "Military Occupation"}})
    }}
  ]) AS total_Military_Occupation,

  // Collect conflict names for each classification
  [conf IN conflicts WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "International Armed Conflict (IAC)"}})
    }} | conf.name
  ] AS IAC_conflict_names,

  [conf IN conflicts WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "Non-International Armed Conflict (NIAC)"}})
    }} | conf.name
  ] AS NIAC_conflict_names,

  [conf IN conflicts WHERE EXISTS {{
      MATCH (conf)-[:IS_CLASSIFIED_AS_CONFLICT_TYPE]->(:ConflictType {{type: "Military Occupation"}})
    }} | conf.name
  ] AS Military_Occupation_conflict_names

////////////////////////////////////////////////////////////////////////
// 7. Build a detailed conflict map array
////////////////////////////////////////////////////////////////////////
WITH
  actor_name_and_aliases,
  total_conflicts,
  total_IAC,
  total_NIAC,
  total_Military_Occupation,
  IAC_conflict_names,
  NIAC_conflict_names,
  Military_Occupation_conflict_names,
  conflicts,
  all_actors,
  conflict_types,

  [conf IN conflicts |
    {{
      conflict_name: COALESCE(conf.name, "Unknown"),
      conflict_classification: COALESCE(
        [item IN conflict_types WHERE item.conflict = conf | item.type][0],
        "Unclassified"
      ),
      conflict_overview: COALESCE(conf.overview, "No Overview Available"),
      applicable_ihl_law: COALESCE(conf.applicable_law, "Not Specified"),
      conflict_citation: COALESCE(conf.citation, "No Citation Available"),

      state_parties: CASE
        WHEN SIZE([
          p IN all_actors
          WHERE "StateActor" IN labels(p)
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
        ]) = 0
          THEN "No state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors
            WHERE "StateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
            | p.name
          ],
          ", "
        )
      END,

      non_state_parties: CASE
        WHEN SIZE([
          p IN all_actors
          WHERE "NonStateActor" IN labels(p)
            AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
        ]) = 0
          THEN "No non-state actors recorded"
        ELSE apoc.text.join(
          [
            p IN all_actors
            WHERE "NonStateActor" IN labels(p)
              AND (p)-[:IS_PARTY_TO_CONFLICT]->(conf)
            | p.name
          ],
          ", "
        )
      END
    }}
  ] AS conflict_details

////////////////////////////////////////////////////////////////////////
// 8. Build a dynamic summary about the total and classification breakdown
////////////////////////////////////////////////////////////////////////
WITH
  actor_name_and_aliases,
  total_conflicts,
  total_IAC,
  total_NIAC,
  total_Military_Occupation,
  IAC_conflict_names,
  NIAC_conflict_names,
  Military_Occupation_conflict_names,
  conflict_details,

  CASE
    WHEN total_conflicts = 0 THEN
      "According to RULAC, there are currently no recorded armed conflicts involving "
      + apoc.text.join(actor_name_and_aliases, ", ") + " as a non-state actor."
    ELSE
      "According to RULAC, there are currently " + toString(total_conflicts)
      + " total distinct armed conflict(s) involving " + apoc.text.join(actor_name_and_aliases, ", ")
      + " as a non-state actor. "

      + CASE WHEN total_IAC > 0 THEN
          toString(total_IAC) + " International Armed Conflict(s) (IAC): "
          + apoc.text.join(IAC_conflict_names, ", ") + ". "
        ELSE
          ""
        END

      + CASE WHEN total_NIAC > 0 THEN
          toString(total_NIAC) + " Non-International Armed Conflict(s) (NIAC): "
          + apoc.text.join(NIAC_conflict_names, ", ") + ". "
        ELSE
          ""
        END

      + CASE WHEN total_Military_Occupation > 0 THEN
          toString(total_Military_Occupation) + " Military Occupation(s): "
          + apoc.text.join(Military_Occupation_conflict_names, ", ") + ". "
        ELSE
          ""
        END
  END AS summary_text

////////////////////////////////////////////////////////////////////////
// 9. Return summary and detailed conflicts as RULAC_research
////////////////////////////////////////////////////////////////////////
RETURN {{
  summary: summary_text,
  conflict_details: CASE
    WHEN total_conflicts = 0 THEN []
    ELSE conflict_details
  END
}} AS RULAC_research





# Here is your research question:
{question}

Remember, your task is to return a cypher query. Do not add line breaks or new lines like /n Only provide the cypher query and nothing else. Do not start with the word "cypher"